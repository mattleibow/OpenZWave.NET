// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace OpenZWave
{
    public unsafe partial class Bitfield : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Vector.__Internalc__N_std_N___1_S_vector__i___N_std_N___1_S_allocator__i m_bits;

            [FieldOffset(24)]
            internal uint m_numSetBits;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave8BitfieldC2Ev")]
            internal static extern void ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave8BitfieldC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave8BitfieldD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave8Bitfield3SetEj")]
            internal static extern void Set(global::System.IntPtr instance, uint _idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave8Bitfield5ClearEj")]
            internal static extern void Clear(global::System.IntPtr instance, uint _idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave8Bitfield5IsSetEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSet(global::System.IntPtr instance, uint _idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave8Bitfield5BeginEv")]
            internal static extern global::OpenZWave.Bitfield.Iterator.__Internal Begin(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave8Bitfield3EndEv")]
            internal static extern global::OpenZWave.Bitfield.Iterator.__Internal End(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave8Bitfield13GetNumSetBitsEv")]
            internal static extern uint GetNumSetBits(global::System.IntPtr instance);
        }

        public unsafe partial class Iterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint m_idx;

                [FieldOffset(8)]
                internal global::System.IntPtr m_bitfield;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave8Bitfield8IteratorC2ERKS1_")]
                internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave8Bitfield8IteratorppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave8Bitfield8IteratoreqERKS1_")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr rhs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave8Bitfield8IteratorneERKS1_")]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr rhs);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Bitfield.Iterator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Bitfield.Iterator>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::OpenZWave.Bitfield.Iterator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::OpenZWave.Bitfield.Iterator(native.ToPointer(), skipVTables);
            }

            internal static global::OpenZWave.Bitfield.Iterator __CreateInstance(global::OpenZWave.Bitfield.Iterator.__Internal native, bool skipVTables = false)
            {
                return new global::OpenZWave.Bitfield.Iterator(native, skipVTables);
            }

            private static void* __CopyValue(global::OpenZWave.Bitfield.Iterator.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Bitfield.Iterator.__Internal));
                *(global::OpenZWave.Bitfield.Iterator.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Iterator(global::OpenZWave.Bitfield.Iterator.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Iterator(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Iterator(global::OpenZWave.Bitfield.Iterator _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Bitfield.Iterator.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::OpenZWave.Bitfield.Iterator.__Internal*) __Instance) = *((global::OpenZWave.Bitfield.Iterator.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::OpenZWave.Bitfield.Iterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::OpenZWave.Bitfield.Iterator operator ++(global::OpenZWave.Bitfield.Iterator __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorPlusPlus(__arg0);
                global::OpenZWave.Bitfield.Iterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::OpenZWave.Bitfield.Iterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::OpenZWave.Bitfield.Iterator) global::OpenZWave.Bitfield.Iterator.NativeToManagedMap[__ret];
                else __result0 = global::OpenZWave.Bitfield.Iterator.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator ==(global::OpenZWave.Bitfield.Iterator __op, global::OpenZWave.Bitfield.Iterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return __opNull && rhsNull;
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as global::OpenZWave.Bitfield.Iterator;
            }

            public override int GetHashCode()
            {
                if (__Instance == global::System.IntPtr.Zero)
                    return global::System.IntPtr.Zero.GetHashCode();
                return (*(global::OpenZWave.Bitfield.Iterator.__Internal*) __Instance).GetHashCode();
            }

            public static bool operator !=(global::OpenZWave.Bitfield.Iterator __op, global::OpenZWave.Bitfield.Iterator rhs)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool rhsNull = ReferenceEquals(rhs, null);
                if (__opNull || rhsNull)
                    return !(__opNull && rhsNull);
                var __arg0 = __op.__Instance;
                var __arg1 = rhs.__Instance;
                var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
                return __ret;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Bitfield> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Bitfield>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Bitfield __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Bitfield(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Bitfield __CreateInstance(global::OpenZWave.Bitfield.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Bitfield(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Bitfield.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Bitfield.__Internal));
            global::OpenZWave.Bitfield.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Bitfield(global::OpenZWave.Bitfield.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Bitfield(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Bitfield()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Bitfield.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public Bitfield(global::OpenZWave.Bitfield _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Bitfield.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Bitfield __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Set(uint _idx)
        {
            __Internal.Set((__Instance + __PointerAdjustment), _idx);
        }

        public void Clear(uint _idx)
        {
            __Internal.Clear((__Instance + __PointerAdjustment), _idx);
        }

        public bool IsSet(uint _idx)
        {
            var __ret = __Internal.IsSet((__Instance + __PointerAdjustment), _idx);
            return __ret;
        }

        public global::OpenZWave.Bitfield.Iterator Begin()
        {
            var __ret = __Internal.Begin((__Instance + __PointerAdjustment));
            return global::OpenZWave.Bitfield.Iterator.__CreateInstance(__ret);
        }

        public global::OpenZWave.Bitfield.Iterator End()
        {
            var __ret = __Internal.End((__Instance + __PointerAdjustment));
            return global::OpenZWave.Bitfield.Iterator.__CreateInstance(__ret);
        }

        public uint NumSetBits
        {
            get
            {
                var __ret = __Internal.GetNumSetBits((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>Exception Handling Interface.</summary>
    /// <remarks>
    /// <para>This class is for exporting errors etc when using the OpenZWave API. It can report incorrect API usage</para>
    /// <para>(such as passing incorrect ValueID's to the Manager::SetValue methods) or</para>
    /// </remarks>
    public unsafe partial class OZWException : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_exception;

            [FieldOffset(8)]
            internal global::Std.LibcppRefstring.__Internal __imp_;

            [FieldOffset(16)]
            internal global::OpenZWave.OZWException.ExceptionType m_exitCode;

            [FieldOffset(24)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_file;

            [FieldOffset(48)]
            internal uint m_line;

            [FieldOffset(56)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_msg;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12OZWExceptionC2ENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEiNS0_13ExceptionTypeES7_")]
            internal static extern void ctor(global::System.IntPtr instance, global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C file, int line, global::OpenZWave.OZWException.ExceptionType exitCode, global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12OZWExceptionC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12OZWException7GetTypeEv")]
            internal static extern global::OpenZWave.OZWException.ExceptionType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12OZWException7GetFileEv")]
            internal static extern void GetFile(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12OZWException7GetLineEv")]
            internal static extern uint GetLine(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12OZWException6GetMsgEv")]
            internal static extern void GetMsg(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public enum ExceptionType : uint
        {
            OZWEXCEPTION_OPTIONS = 0,
            OZWEXCEPTION_CONFIG = 1,
            OZWEXCEPTION_INVALID_HOMEID = 100,
            OZWEXCEPTION_INVALID_VALUEID = 101,
            OZWEXCEPTION_CANNOT_CONVERT_VALUEID = 102,
            OZWEXCEPTION_SECURITY_FAILED = 103
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.OZWException> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.OZWException>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.OZWException __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.OZWException(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.OZWException __CreateInstance(global::OpenZWave.OZWException.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.OZWException(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.OZWException.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.OZWException.__Internal));
            global::OpenZWave.OZWException.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private OZWException(global::OpenZWave.OZWException.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OZWException(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public OZWException(string file, int line, global::OpenZWave.OZWException.ExceptionType exitCode, string msg)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.OZWException.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(file, __allocator0);
            var __arg0 = *(global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C*) __basicString0.__Instance;
            var __allocator3 = new global::Std.Allocator<sbyte>();
            var __basicString3 = global::Std.BasicStringExtensions.BasicString(msg, __allocator3);
            var __arg3 = *(global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C*) __basicString3.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, line, exitCode, __arg3);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString3.Dispose(false);
            __allocator3.Dispose();
            SetupVTables(GetType().FullName == "OpenZWave.OZWException");
        }

        public OZWException(global::OpenZWave.OZWException _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.OZWException.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "OpenZWave.OZWException");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.OZWException __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::OpenZWave.OZWException.__Internal*) __Instance)->vptr_exception = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                var ___dtorDelegate = (global::OpenZWave.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr));
                ___dtorDelegate((__Instance + __PointerAdjustment));
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::OpenZWave.OZWException.ExceptionType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string File
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetFile(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint Line
        {
            get
            {
                var __ret = __Internal.GetLine((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string Msg
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetMsg(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        #region Virtual table interop

        // ~OZWException() throw() { }
        private static global::OpenZWave.Delegates.Action_IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.OZWException) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 8);
                    var vfptr0 = vtptr + 2 * 8;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -16);
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(5 * 8);
                    var vfptr0 = vtptr + 2 * 8;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -16);
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace OpenZWave
{
    public unsafe partial class Thread
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Thread> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Thread>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Thread __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Thread(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Thread __CreateInstance(global::OpenZWave.Thread.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Thread(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Thread.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Thread.__Internal));
            *(global::OpenZWave.Thread.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Thread(global::OpenZWave.Thread.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Thread(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Controller
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Controller> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Controller>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Controller __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Controller(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Controller __CreateInstance(global::OpenZWave.Controller.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Controller(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Controller.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Controller.__Internal));
            *(global::OpenZWave.Controller.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Controller(global::OpenZWave.Controller.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Controller(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>
    /// <para>The Driver class handles communication between OpenZWave</para>
    /// <para>and a device attached via a serial port (typically a controller).</para>
    /// </summary>
    public unsafe partial class Driver : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2792)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_Driver;

            [FieldOffset(8)]
            internal global::System.IntPtr m_driverThread;

            [FieldOffset(16)]
            internal global::System.IntPtr m_initMutex;

            [FieldOffset(24)]
            internal byte m_exit;

            [FieldOffset(25)]
            internal byte m_init;

            [FieldOffset(26)]
            internal byte m_awakeNodesQueried;

            [FieldOffset(27)]
            internal byte m_allNodesQueried;

            [FieldOffset(28)]
            internal byte m_notifytransactions;

            [FieldOffset(32)]
            internal global::OpenZWave.TimeStamp.__Internal m_startTime;

            [FieldOffset(40)]
            internal global::OpenZWave.Driver.ControllerInterface m_controllerInterfaceType;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_controllerPath;

            [FieldOffset(72)]
            internal global::System.IntPtr m_controller;

            [FieldOffset(80)]
            internal uint m_homeId;

            [FieldOffset(88)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_libraryVersion;

            [FieldOffset(112)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_libraryTypeName;

            [FieldOffset(136)]
            internal byte m_libraryType;

            [FieldOffset(137)]
            internal fixed byte m_serialAPIVersion[2];

            [FieldOffset(140)]
            internal ushort m_manufacturerId;

            [FieldOffset(142)]
            internal ushort m_productType;

            [FieldOffset(144)]
            internal ushort m_productId;

            [FieldOffset(146)]
            internal fixed byte m_apiMask[32];

            [FieldOffset(178)]
            internal byte m_initVersion;

            [FieldOffset(179)]
            internal byte m_initCaps;

            [FieldOffset(180)]
            internal byte m_controllerCaps;

            [FieldOffset(181)]
            internal byte m_Controller_nodeId;

            [FieldOffset(184)]
            internal fixed long m_nodes[256];

            [FieldOffset(2232)]
            internal global::System.IntPtr m_nodeMutex;

            [FieldOffset(2240)]
            internal global::System.IntPtr m_controllerReplication;

            [FieldOffset(2248)]
            internal byte m_transmitOptions;

            [FieldOffset(2249)]
            internal byte m_waitingForAck;

            [FieldOffset(2250)]
            internal byte m_expectedCallbackId;

            [FieldOffset(2251)]
            internal byte m_expectedReply;

            [FieldOffset(2252)]
            internal byte m_expectedCommandClassId;

            [FieldOffset(2253)]
            internal byte m_expectedNodeId;

            [FieldOffset(2256)]
            internal global::System.IntPtr m_pollThread;

            [FieldOffset(2264)]
            internal global::Std.List.__Internalc__N_std_N___1_S_list____N_OpenZWave_S_Driver_S_PollEntry___N_std_N___1_S_allocator__S0_ m_pollList;

            [FieldOffset(2288)]
            internal global::System.IntPtr m_pollMutex;

            [FieldOffset(2296)]
            internal int m_pollInterval;

            [FieldOffset(2300)]
            internal byte m_bIntervalBetweenPolls;

            [FieldOffset(2304)]
            internal global::System.IntPtr m_currentControllerCommand;

            [FieldOffset(2312)]
            internal byte m_SUCNodeId;

            [FieldOffset(2320)]
            internal global::System.IntPtr m_controllerResetEvent;

            [FieldOffset(2328)]
            internal fixed byte m_msgQueue[192];

            [FieldOffset(2520)]
            internal fixed long m_queueEvent[8];

            [FieldOffset(2584)]
            internal global::System.IntPtr m_sendMutex;

            [FieldOffset(2592)]
            internal global::System.IntPtr m_currentMsg;

            [FieldOffset(2600)]
            internal global::OpenZWave.Driver.MsgQueue m_currentMsgQueueSource;

            [FieldOffset(2608)]
            internal global::OpenZWave.TimeStamp.__Internal m_resendTimeStamp;

            [FieldOffset(2616)]
            internal byte m_virtualNeighborsReceived;

            [FieldOffset(2617)]
            internal fixed byte m_virtualNeighbors[29];

            [FieldOffset(2648)]
            internal global::Std.List.__Internalc__N_std_N___1_S_list_____N_OpenZWave_S_Notification___N_std_N___1_S_allocator__S0_ m_notifications;

            [FieldOffset(2672)]
            internal global::System.IntPtr m_notificationsEvent;

            [FieldOffset(2680)]
            internal uint m_SOFCnt;

            [FieldOffset(2684)]
            internal uint m_ACKWaiting;

            [FieldOffset(2688)]
            internal uint m_readAborts;

            [FieldOffset(2692)]
            internal uint m_badChecksum;

            [FieldOffset(2696)]
            internal uint m_readCnt;

            [FieldOffset(2700)]
            internal uint m_writeCnt;

            [FieldOffset(2704)]
            internal uint m_CANCnt;

            [FieldOffset(2708)]
            internal uint m_NAKCnt;

            [FieldOffset(2712)]
            internal uint m_ACKCnt;

            [FieldOffset(2716)]
            internal uint m_OOFCnt;

            [FieldOffset(2720)]
            internal uint m_dropped;

            [FieldOffset(2724)]
            internal uint m_retries;

            [FieldOffset(2728)]
            internal uint m_callbacks;

            [FieldOffset(2732)]
            internal uint m_badroutes;

            [FieldOffset(2736)]
            internal uint m_noack;

            [FieldOffset(2740)]
            internal uint m_netbusy;

            [FieldOffset(2744)]
            internal uint m_notidle;

            [FieldOffset(2748)]
            internal uint m_nondelivery;

            [FieldOffset(2752)]
            internal uint m_routedbusy;

            [FieldOffset(2756)]
            internal uint m_broadcastReadCnt;

            [FieldOffset(2760)]
            internal uint m_broadcastWriteCnt;

            [FieldOffset(2768)]
            internal global::System.IntPtr AuthKey;

            [FieldOffset(2776)]
            internal global::System.IntPtr EncryptKey;

            [FieldOffset(2784)]
            internal byte m_nonceReportSent;

            [FieldOffset(2785)]
            internal byte m_nonceReportSentAttempt;

            [FieldOffset(2786)]
            internal byte m_inclusionkeySet;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave6DriverC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave6Driver13GetNodeNumberEPKNS_3MsgE")]
            internal static extern byte GetNodeNumber(global::System.IntPtr instance, global::System.IntPtr _msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave6Driver7SendMsgEPNS_3MsgENS0_8MsgQueueE")]
            internal static extern void SendMsg(global::System.IntPtr instance, global::System.IntPtr _msg, global::OpenZWave.Driver.MsgQueue _queue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave6Driver19LogDriverStatisticsEv")]
            internal static extern void LogDriverStatistics(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave6Driver18GetTransmitOptionsEv")]
            internal static extern byte GetTransmitOptions(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave6Driver15isNetworkKeySetEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNetworkKeySet(global::System.IntPtr instance);
        }

        public enum ControllerInterface : uint
        {
            ControllerInterfaceUnknown = 0,
            ControllerInterfaceSerial = 1,
            ControllerInterfaceHid = 2
        }

        /// <summary>
        /// <para>Controller States.</para>
        /// <para>States reported via the callback handler passed into the BeginControllerCommand method.</para>
        /// </summary>
        /// <remarks>Manager::BeginControllerCommand</remarks>
        public enum ControllerState : uint
        {
            /// <summary>No command in progress.</summary>
            ControllerStateNormal = 0,
            /// <summary>The command is starting.</summary>
            ControllerStateStarting = 1,
            /// <summary>The command was canceled.</summary>
            ControllerStateCancel = 2,
            /// <summary>Command invocation had error(s) and was aborted</summary>
            ControllerStateError = 3,
            /// <summary>Controller is waiting for a user action.</summary>
            ControllerStateWaiting = 4,
            /// <summary>Controller command is on a sleep queue wait for device.</summary>
            ControllerStateSleeping = 5,
            /// <summary>The controller is communicating with the other device to carry out the command.</summary>
            ControllerStateInProgress = 6,
            /// <summary>The command has completed successfully.</summary>
            ControllerStateCompleted = 7,
            /// <summary>The command has failed.</summary>
            ControllerStateFailed = 8,
            /// <summary>Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node is OK.</summary>
            ControllerStateNodeOK = 9,
            /// <summary>Used only with ControllerCommand_HasNodeFailed to indicate that the controller thinks the node has failed.</summary>
            ControllerStateNodeFailed = 10
        }

        /// <summary>
        /// <para>Controller Commands.</para>
        /// <para>Commands to be used with the BeginControllerCommand method.</para>
        /// </summary>
        /// <remarks>Manager::BeginControllerCommand</remarks>
        public enum ControllerCommand : uint
        {
            /// <summary>No command.</summary>
            ControllerCommandNone = 0,
            /// <summary>Add a new device or controller to the Z-Wave network.</summary>
            ControllerCommandAddDevice = 1,
            /// <summary>Add a new controller to the Z-Wave network. Used when old primary fails. Requires SUC.</summary>
            ControllerCommandCreateNewPrimary = 2,
            /// <summary>Receive Z-Wave network configuration information from another controller.</summary>
            ControllerCommandReceiveConfiguration = 3,
            /// <summary>Remove a device or controller from the Z-Wave network.</summary>
            ControllerCommandRemoveDevice = 4,
            /// <summary>Move a node to the controller's failed nodes list. This command will only work if the node cannot respond.</summary>
            ControllerCommandRemoveFailedNode = 5,
            /// <summary>Check whether a node is in the controller's failed nodes list.</summary>
            ControllerCommandHasNodeFailed = 6,
            /// <summary>Replace a non-responding node with another. The node must be in the controller's list of failed nodes for this command to succeed.</summary>
            ControllerCommandReplaceFailedNode = 7,
            /// <summary>Make a different controller the primary.</summary>
            ControllerCommandTransferPrimaryRole = 8,
            /// <summary>Request network information from the SUC/SIS.</summary>
            ControllerCommandRequestNetworkUpdate = 9,
            /// <summary>Get a node to rebuild its neighbour list.  This method also does RequestNodeNeighbors</summary>
            ControllerCommandRequestNodeNeighborUpdate = 10,
            /// <summary>Assign a network return routes to a device.</summary>
            ControllerCommandAssignReturnRoute = 11,
            /// <summary>Delete all return routes from a device.</summary>
            ControllerCommandDeleteAllReturnRoutes = 12,
            /// <summary>Send a node information frame</summary>
            ControllerCommandSendNodeInformation = 13,
            /// <summary>Send information from primary to secondary</summary>
            ControllerCommandReplicationSend = 14,
            /// <summary>Create an id that tracks handheld button presses</summary>
            ControllerCommandCreateButton = 15,
            /// <summary>Delete id that tracks handheld button presses</summary>
            ControllerCommandDeleteButton = 16
        }

        /// <summary>
        /// <para>Controller Errors</para>
        /// <para>Provide some more information about controller failures.</para>
        /// </summary>
        public enum ControllerError : uint
        {
            ControllerErrorNone = 0,
            /// <summary>Button</summary>
            ControllerErrorButtonNotFound = 1,
            /// <summary>Button</summary>
            ControllerErrorNodeNotFound = 2,
            /// <summary>Button</summary>
            ControllerErrorNotBridge = 3,
            /// <summary>CreateNewPrimary</summary>
            ControllerErrorNotSUC = 4,
            /// <summary>CreateNewPrimary</summary>
            ControllerErrorNotSecondary = 5,
            /// <summary>RemoveFailedNode, AddNodeToNetwork</summary>
            ControllerErrorNotPrimary = 6,
            /// <summary>ReceiveConfiguration</summary>
            ControllerErrorIsPrimary = 7,
            /// <summary>RemoveFailedNode</summary>
            ControllerErrorNotFound = 8,
            /// <summary>RemoveFailedNode, RequestNetworkUpdate</summary>
            ControllerErrorBusy = 9,
            /// <summary>RemoveFailedNode, RequestNetworkUpdate</summary>
            ControllerErrorFailed = 10,
            /// <summary>RequestNetworkUpdate error</summary>
            ControllerErrorDisabled = 11,
            /// <summary>RequestNetworkUpdate error</summary>
            ControllerErrorOverflow = 12
        }

        public enum MsgQueue : uint
        {
            MsgQueueCommand = 0,
            MsgQueueSecurity = 1,
            MsgQueueNoOp = 2,
            MsgQueueController = 3,
            MsgQueueWakeUp = 4,
            MsgQueueSend = 5,
            MsgQueueQuery = 6,
            MsgQueuePoll = 7,
            MsgQueueCount = 8
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void PfnControllerCallbackT(global::OpenZWave.Driver.ControllerState _state, global::OpenZWave.Driver.ControllerError _err, global::System.IntPtr _context);

        public unsafe partial class PollEntry : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::OpenZWave.ValueID.__Internal m_id;

                [FieldOffset(12)]
                internal byte m_pollCounter;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave6Driver9PollEntryC2Ev")]
                internal static extern void ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave6Driver9PollEntryC2ERKS1_")]
                internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Driver.PollEntry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Driver.PollEntry>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::OpenZWave.Driver.PollEntry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::OpenZWave.Driver.PollEntry(native.ToPointer(), skipVTables);
            }

            internal static global::OpenZWave.Driver.PollEntry __CreateInstance(global::OpenZWave.Driver.PollEntry.__Internal native, bool skipVTables = false)
            {
                return new global::OpenZWave.Driver.PollEntry(native, skipVTables);
            }

            private static void* __CopyValue(global::OpenZWave.Driver.PollEntry.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.PollEntry.__Internal));
                *(global::OpenZWave.Driver.PollEntry.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PollEntry(global::OpenZWave.Driver.PollEntry.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PollEntry(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public PollEntry()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.PollEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public PollEntry(global::OpenZWave.Driver.PollEntry _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.PollEntry.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::OpenZWave.Driver.PollEntry.__Internal*) __Instance) = *((global::OpenZWave.Driver.PollEntry.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::OpenZWave.Driver.PollEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::OpenZWave.ValueID MId
            {
                get
                {
                    return global::OpenZWave.ValueID.__CreateInstance(new global::System.IntPtr(&((global::OpenZWave.Driver.PollEntry.__Internal*) __Instance)->m_id));
                }

                set
                {
                    ((global::OpenZWave.Driver.PollEntry.__Internal*)__Instance)->m_id = ReferenceEquals(value, null) ? new global::OpenZWave.ValueID.__Internal() : *(global::OpenZWave.ValueID.__Internal*) value.__Instance;
                }
            }

            public byte MPollCounter
            {
                get
                {
                    return ((global::OpenZWave.Driver.PollEntry.__Internal*) __Instance)->m_pollCounter;
                }

                set
                {
                    ((global::OpenZWave.Driver.PollEntry.__Internal*)__Instance)->m_pollCounter = value;
                }
            }
        }

        public unsafe partial class DriverData : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 84)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint m_SOFCnt;

                [FieldOffset(4)]
                internal uint m_ACKWaiting;

                [FieldOffset(8)]
                internal uint m_readAborts;

                [FieldOffset(12)]
                internal uint m_badChecksum;

                [FieldOffset(16)]
                internal uint m_readCnt;

                [FieldOffset(20)]
                internal uint m_writeCnt;

                [FieldOffset(24)]
                internal uint m_CANCnt;

                [FieldOffset(28)]
                internal uint m_NAKCnt;

                [FieldOffset(32)]
                internal uint m_ACKCnt;

                [FieldOffset(36)]
                internal uint m_OOFCnt;

                [FieldOffset(40)]
                internal uint m_dropped;

                [FieldOffset(44)]
                internal uint m_retries;

                [FieldOffset(48)]
                internal uint m_callbacks;

                [FieldOffset(52)]
                internal uint m_badroutes;

                [FieldOffset(56)]
                internal uint m_noack;

                [FieldOffset(60)]
                internal uint m_netbusy;

                [FieldOffset(64)]
                internal uint m_notidle;

                [FieldOffset(68)]
                internal uint m_nondelivery;

                [FieldOffset(72)]
                internal uint m_routedbusy;

                [FieldOffset(76)]
                internal uint m_broadcastReadCnt;

                [FieldOffset(80)]
                internal uint m_broadcastWriteCnt;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave6Driver10DriverDataC2ERKS1_")]
                internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Driver.DriverData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Driver.DriverData>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::OpenZWave.Driver.DriverData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::OpenZWave.Driver.DriverData(native.ToPointer(), skipVTables);
            }

            internal static global::OpenZWave.Driver.DriverData __CreateInstance(global::OpenZWave.Driver.DriverData.__Internal native, bool skipVTables = false)
            {
                return new global::OpenZWave.Driver.DriverData(native, skipVTables);
            }

            private static void* __CopyValue(global::OpenZWave.Driver.DriverData.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.DriverData.__Internal));
                *(global::OpenZWave.Driver.DriverData.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DriverData(global::OpenZWave.Driver.DriverData.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DriverData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public DriverData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.DriverData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public DriverData(global::OpenZWave.Driver.DriverData _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.DriverData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::OpenZWave.Driver.DriverData.__Internal*) __Instance) = *((global::OpenZWave.Driver.DriverData.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::OpenZWave.Driver.DriverData __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint MSOFCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_SOFCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_SOFCnt = value;
                }
            }

            public uint MACKWaiting
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_ACKWaiting;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_ACKWaiting = value;
                }
            }

            public uint MReadAborts
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_readAborts;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_readAborts = value;
                }
            }

            public uint MBadChecksum
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_badChecksum;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_badChecksum = value;
                }
            }

            public uint MReadCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_readCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_readCnt = value;
                }
            }

            public uint MWriteCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_writeCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_writeCnt = value;
                }
            }

            public uint MCANCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_CANCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_CANCnt = value;
                }
            }

            public uint MNAKCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_NAKCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_NAKCnt = value;
                }
            }

            public uint MACKCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_ACKCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_ACKCnt = value;
                }
            }

            public uint MOOFCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_OOFCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_OOFCnt = value;
                }
            }

            public uint MDropped
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_dropped;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_dropped = value;
                }
            }

            public uint MRetries
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_retries;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_retries = value;
                }
            }

            public uint MCallbacks
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_callbacks;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_callbacks = value;
                }
            }

            public uint MBadroutes
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_badroutes;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_badroutes = value;
                }
            }

            public uint MNoack
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_noack;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_noack = value;
                }
            }

            public uint MNetbusy
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_netbusy;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_netbusy = value;
                }
            }

            public uint MNotidle
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_notidle;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_notidle = value;
                }
            }

            public uint MNondelivery
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_nondelivery;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_nondelivery = value;
                }
            }

            public uint MRoutedbusy
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_routedbusy;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_routedbusy = value;
                }
            }

            public uint MBroadcastReadCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_broadcastReadCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_broadcastReadCnt = value;
                }
            }

            public uint MBroadcastWriteCnt
            {
                get
                {
                    return ((global::OpenZWave.Driver.DriverData.__Internal*) __Instance)->m_broadcastWriteCnt;
                }

                set
                {
                    ((global::OpenZWave.Driver.DriverData.__Internal*)__Instance)->m_broadcastWriteCnt = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Driver> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Driver>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Driver __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Driver(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Driver __CreateInstance(global::OpenZWave.Driver.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Driver(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Driver.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.__Internal));
            global::OpenZWave.Driver.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Driver(global::OpenZWave.Driver.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Driver(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Driver(global::OpenZWave.Driver _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Driver.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Driver __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte GetNodeNumber(global::OpenZWave.Msg _msg)
        {
            var __arg0 = ReferenceEquals(_msg, null) ? global::System.IntPtr.Zero : _msg.__Instance;
            var __ret = __Internal.GetNodeNumber((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void SendMsg(global::OpenZWave.Msg _msg, global::OpenZWave.Driver.MsgQueue _queue)
        {
            var __arg0 = ReferenceEquals(_msg, null) ? global::System.IntPtr.Zero : _msg.__Instance;
            __Internal.SendMsg((__Instance + __PointerAdjustment), __arg0, _queue);
        }

        public void LogDriverStatistics()
        {
            __Internal.LogDriverStatistics((__Instance + __PointerAdjustment));
        }

        /// <summary>Fetch the transmit options</summary>
        public byte TransmitOptions
        {
            get
            {
                var __ret = __Internal.GetTransmitOptions((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsNetworkKeySet
        {
            get
            {
                var __ret = __Internal.IsNetworkKeySet((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>Provides a unique ID for a value reported by a Z-Wave device.</summary>
    /// <remarks>
    /// <para>The ValueID is used to uniquely identify a value reported by a</para>
    /// <para>Z-Wave device.</para>
    /// <para></para>
    /// <para>The ID is built by packing various identifying characteristics into a single</para>
    /// <para>32-bit number - the Z-Wave driver index, device node ID, the command class and</para>
    /// <para>command class instance that handles the value, plus an index for the value</para>
    /// <para>to distinguish it among all the other values managed by that command class</para>
    /// <para>instance.  The type (bool, byte, string etc) of the value is also stored.</para>
    /// <para></para>
    /// <para>The packing of the ID is such that a list of Values sorted by ValueID</para>
    /// <para>will be in a sensible order for display to the user.</para>
    /// </remarks>
    public unsafe partial class ValueID : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint m_id;

            [FieldOffset(4)]
            internal uint m_id1;

            [FieldOffset(8)]
            internal uint m_homeId;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7ValueIDC2EjhNS0_10ValueGenreEhhhNS0_9ValueTypeE")]
            internal static extern void ctor(global::System.IntPtr instance, uint _homeId, byte _nodeId, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::OpenZWave.ValueID.ValueType _type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7ValueIDC2Ejy")]
            internal static extern void ctor(global::System.IntPtr instance, uint _homeId, ulong id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7ValueIDC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueIDeqERKS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr _other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueIDneERKS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual(global::System.IntPtr instance, global::System.IntPtr _other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueIDltERKS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess(global::System.IntPtr instance, global::System.IntPtr _other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueIDgtERKS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorGreater(global::System.IntPtr instance, global::System.IntPtr _other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID9GetHomeIdEv")]
            internal static extern uint GetHomeId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID9GetNodeIdEv")]
            internal static extern byte GetNodeId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID8GetGenreEv")]
            internal static extern global::OpenZWave.ValueID.ValueGenre GetGenre(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID17GetCommandClassIdEv")]
            internal static extern byte GetCommandClassId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID11GetInstanceEv")]
            internal static extern byte GetInstance(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID8GetIndexEv")]
            internal static extern byte GetIndex(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID7GetTypeEv")]
            internal static extern global::OpenZWave.ValueID.ValueType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7ValueID5GetIdEv")]
            internal static extern ulong GetId(global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Value Genres</para>
        /// <para>The classification of a value to enable low level system or configuration parameters to be filtered by the application.</para>
        /// </summary>
        /// <remarks>GetGenre</remarks>
        public enum ValueGenre : uint
        {
            /// <summary>The 'level' as controlled by basic commands.  Usually duplicated by another command class.</summary>
            ValueGenreBasic = 0,
            /// <summary>Basic values an ordinary user would be interested in.</summary>
            ValueGenreUser = 1,
            /// <summary>Device-specific configuration parameters.  These cannot be automatically discovered via Z-Wave, and are usually described in the user manual instead.</summary>
            ValueGenreConfig = 2,
            /// <summary>Values of significance only to users who understand the Z-Wave protocol</summary>
            ValueGenreSystem = 3,
            /// <summary>A count of the number of genres defined.  Not to be used as a genre itself.</summary>
            ValueGenreCount = 4
        }

        /// <summary>
        /// <para>Value Types</para>
        /// <para>The type of data represented by the value object.</para>
        /// </summary>
        /// <remarks>GetType</remarks>
        public enum ValueType : uint
        {
            /// <summary>Boolean, true or false</summary>
            ValueTypeBool = 0,
            /// <summary>8-bit unsigned value</summary>
            ValueTypeByte = 1,
            /// <summary>Represents a non-integer value as a string, to avoid floating point accuracy issues.</summary>
            ValueTypeDecimal = 2,
            /// <summary>32-bit signed value</summary>
            ValueTypeInt = 3,
            /// <summary>List from which one item can be selected</summary>
            ValueTypeList = 4,
            /// <summary>Complex type used with the Climate Control Schedule command class</summary>
            ValueTypeSchedule = 5,
            /// <summary>16-bit signed value</summary>
            ValueTypeShort = 6,
            /// <summary>Text string</summary>
            ValueTypeString = 7,
            /// <summary>A write-only value that is the equivalent of pressing a button to send a command to a device</summary>
            ValueTypeButton = 8,
            /// <summary>A collection of bytes</summary>
            ValueTypeRaw = 9,
            /// <summary>The highest-number type defined.  Not to be used as a type itself.</summary>
            ValueTypeMax = 9
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.ValueID> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.ValueID>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.ValueID __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.ValueID(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.ValueID __CreateInstance(global::OpenZWave.ValueID.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.ValueID(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.ValueID.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ValueID.__Internal));
            *(global::OpenZWave.ValueID.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ValueID(global::OpenZWave.ValueID.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ValueID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Construct a value ID from its component parts.</para>
        /// <para>This method is public only to allow ValueIDs to be saved and recreated by the application.</para>
        /// <para>Only ValueIDs that have been reported by OpenZWave notifications should ever be used.</para>
        /// </summary>
        /// <param name="_homeId">Home ID of the PC Z-Wave Controller that manages the device.</param>
        /// <param name="_nodeId">Node ID of the device reporting the value.</param>
        /// <param name="_genre">classification of the value to enable low level system or configuration parameters to be filtered out.</param>
        /// <param name="_commandClassId">ID of command class that creates and manages this value.</param>
        /// <param name="_instance">Instance index of the command class.</param>
        /// <param name="_valueIndex">Index of the value within all the values created by the command class instance.</param>
        /// <param name="_type">Type of value (bool, byte, string etc).</param>
        /// <returns>The ValueID.</returns>
        /// <remarks>ValueID</remarks>
        public ValueID(uint _homeId, byte _nodeId, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::OpenZWave.ValueID.ValueType _type)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ValueID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), _homeId, _nodeId, _genre, _commandClassId, _instance, _valueIndex, _type);
        }

        public ValueID(uint _homeId, ulong id)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ValueID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), _homeId, id);
        }

        public ValueID(global::OpenZWave.ValueID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ValueID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::OpenZWave.ValueID.__Internal*) __Instance) = *((global::OpenZWave.ValueID.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.ValueID __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static bool operator ==(global::OpenZWave.ValueID __op, global::OpenZWave.ValueID _other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool _otherNull = ReferenceEquals(_other, null);
            if (__opNull || _otherNull)
                return __opNull && _otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = _other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::OpenZWave.ValueID;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::OpenZWave.ValueID.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::OpenZWave.ValueID __op, global::OpenZWave.ValueID _other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool _otherNull = ReferenceEquals(_other, null);
            if (__opNull || _otherNull)
                return !(__opNull && _otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = _other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual(__arg0, __arg1);
            return __ret;
        }

        public static bool operator <(global::OpenZWave.ValueID __op, global::OpenZWave.ValueID _other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(_other, null))
                throw new global::System.ArgumentNullException("_other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _other.__Instance;
            var __ret = __Internal.OperatorLess(__arg0, __arg1);
            return __ret;
        }

        public static bool operator >(global::OpenZWave.ValueID __op, global::OpenZWave.ValueID _other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(_other, null))
                throw new global::System.ArgumentNullException("_other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _other.__Instance;
            var __ret = __Internal.OperatorGreater(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Get the Home ID of the driver that controls the node containing the value.</summary>
        /// <returns>the Home ID.</returns>
        public uint HomeId
        {
            get
            {
                var __ret = __Internal.GetHomeId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the Home ID of the driver that controls the node containing the value.</summary>
        /// <returns>the node id.</returns>
        public byte NodeId
        {
            get
            {
                var __ret = __Internal.GetNodeId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the genre of the value.  The genre classifies a value to enable</para>
        /// <para>low-level system or configuration parameters to be filtered out by the application</para>
        /// </summary>
        /// <returns>the value's genre.</returns>
        /// <remarks>ValueGenre</remarks>
        public global::OpenZWave.ValueID.ValueGenre Genre
        {
            get
            {
                var __ret = __Internal.GetGenre((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the Z-Wave command class that created and manages this value.  Knowledge of</para>
        /// <para>command classes is not required to use OpenZWave, but this information is</para>
        /// <para>exposed in case it is of interest.</para>
        /// </summary>
        /// <returns>the value's command class.</returns>
        public byte CommandClassId
        {
            get
            {
                var __ret = __Internal.GetCommandClassId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the command class instance of this value.  It is possible for there to be</para>
        /// <para>multiple instances of a command class, although currently it appears that</para>
        /// <para>only the SensorMultilevel command class ever does this.  Knowledge of</para>
        /// <para>instances and command classes is not required to use OpenZWave, but this</para>
        /// <para>information is exposed in case it is of interest.</para>
        /// </summary>
        /// <returns>the instance of the value's command class.</returns>
        public byte Instance
        {
            get
            {
                var __ret = __Internal.GetInstance((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the value index.  The index is used to identify one of multiple</para>
        /// <para>values created and managed by a command class.  In the case of configurable</para>
        /// <para>parameters (handled by the configuration command class), the index is the</para>
        /// <para>same as the parameter ID.  Knowledge of command classes is not required</para>
        /// <para>to use OpenZWave, but this information is exposed in case it is of interest.</para>
        /// </summary>
        /// <returns>the value index within the command class.</returns>
        public byte Index
        {
            get
            {
                var __ret = __Internal.GetIndex((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the type of the value.  The type describes the data held by the value</para>
        /// <para>and enables the user to select the correct value accessor method in the</para>
        /// <para>Manager class.</para>
        /// </summary>
        /// <returns>the value's type.</returns>
        /// <remarks>ValueType, Manager::GetValueAsBool, Manager::GetValueAsByte, Manager::GetValueAsFloat, Manager::GetValueAsInt, Manager::GetValueAsShort, Manager::GetValueAsString, Manager::GetValueListSelection.</remarks>
        public global::OpenZWave.ValueID.ValueType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get a 64Bit Integer that represents this ValueID. This Integer is not guaranteed to be valid</para>
        /// <para>across restarts of OpenZWave.</para>
        /// </summary>
        /// <returns>a uint64 integer</returns>
        public ulong Id
        {
            get
            {
                var __ret = __Internal.GetId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>Message object to be passed to and from devices on the Z-Wave network.</summary>
    public unsafe partial class Msg : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 568)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_logText;

            [FieldOffset(24)]
            internal byte m_bFinal;

            [FieldOffset(25)]
            internal byte m_bCallbackRequired;

            [FieldOffset(26)]
            internal byte m_callbackId;

            [FieldOffset(27)]
            internal byte m_expectedReply;

            [FieldOffset(28)]
            internal byte m_expectedCommandClassId;

            [FieldOffset(29)]
            internal byte m_length;

            [FieldOffset(30)]
            internal fixed byte m_buffer[256];

            [FieldOffset(286)]
            internal fixed byte e_buffer[256];

            [FieldOffset(542)]
            internal byte m_targetNodeId;

            [FieldOffset(543)]
            internal byte m_sendAttempts;

            [FieldOffset(544)]
            internal byte m_maxSendAttempts;

            [FieldOffset(545)]
            internal byte m_instance;

            [FieldOffset(546)]
            internal byte m_endPoint;

            [FieldOffset(547)]
            internal byte m_flags;

            [FieldOffset(548)]
            internal byte m_encrypted;

            [FieldOffset(549)]
            internal byte m_noncerecvd;

            [FieldOffset(550)]
            internal fixed byte m_nonce[8];

            [FieldOffset(560)]
            internal uint m_homeId;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3MsgC2ERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEhhhbbhh")]
            internal static extern void ctor(global::System.IntPtr instance, global::System.IntPtr _logtext, byte _targetNodeId, byte _msgType, byte _function, bool _bCallbackRequired, bool _bReplyRequired, byte _expectedReply, byte _expectedCommandClassId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3MsgC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3MsgD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg6AppendEh")]
            internal static extern void Append(global::System.IntPtr instance, byte _data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg8FinalizeEv")]
            internal static extern void FinalizeMessage(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg16UpdateCallbackIdEv")]
            internal static extern void UpdateCallbackId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3MsgeqERKS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual(global::System.IntPtr instance, global::System.IntPtr _other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg12setEncryptedEv")]
            internal static extern void SetEncrypted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg8setNonceEPh")]
            internal static extern void SetNonce(global::System.IntPtr instance, byte[] nonce);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg10clearNonceEv")]
            internal static extern void ClearNonce(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg9SetHomeIdEj")]
            internal static extern void SetHomeId(global::System.IntPtr instance, uint homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg15GetSendAttemptsEv")]
            internal static extern byte GetSendAttempts(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg15SetSendAttemptsEh")]
            internal static extern void SetSendAttempts(global::System.IntPtr instance, byte _count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg18GetMaxSendAttemptsEv")]
            internal static extern byte GetMaxSendAttempts(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg18SetMaxSendAttemptsEh")]
            internal static extern void SetMaxSendAttempts(global::System.IntPtr instance, byte _count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg15GetTargetNodeIdEv")]
            internal static extern byte GetTargetNodeId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg13GetCallbackIdEv")]
            internal static extern byte GetCallbackId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg16GetExpectedReplyEv")]
            internal static extern byte GetExpectedReply(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg25GetExpectedCommandClassIdEv")]
            internal static extern byte GetExpectedCommandClassId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg19GetExpectedInstanceEv")]
            internal static extern byte GetExpectedInstance(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg10GetLogTextEv")]
            internal static extern void GetLogText(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg9GetLengthEv")]
            internal static extern uint GetLength(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg9GetBufferEv")]
            internal static extern byte* GetBuffer(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg11GetAsStringEv")]
            internal static extern void GetAsString(global::System.IntPtr @return, global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg32IsWakeUpNoMoreInformationCommandEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWakeUpNoMoreInformationCommand(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg13IsNoOperationEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNoOperation(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg22GetSendingCommandClassEv")]
            internal static extern byte GetSendingCommandClass(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg11isEncryptedEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsEncrypted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Msg15isNonceRecievedEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNonceRecieved(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave3Msg9GetDriverEv")]
            internal static extern global::System.IntPtr GetDriver(global::System.IntPtr instance);
        }

        public enum MessageFlags : uint
        {
            mMultiChannel = 0x1,
            mMultiInstance = 0x2
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Msg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Msg>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Msg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Msg(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Msg __CreateInstance(global::OpenZWave.Msg.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Msg(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Msg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Msg.__Internal));
            global::OpenZWave.Msg.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Msg(global::OpenZWave.Msg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Msg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Msg(string _logtext, byte _targetNodeId, byte _msgType, byte _function, bool _bCallbackRequired, bool _bReplyRequired, byte _expectedReply, byte _expectedCommandClassId)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Msg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_logtext, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor((__Instance + __PointerAdjustment), __arg0, _targetNodeId, _msgType, _function, _bCallbackRequired, _bReplyRequired, _expectedReply, _expectedCommandClassId);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public Msg(global::OpenZWave.Msg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Msg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Msg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Append(byte _data)
        {
            __Internal.Append((__Instance + __PointerAdjustment), _data);
        }

        public void FinalizeMessage()
        {
            __Internal.FinalizeMessage((__Instance + __PointerAdjustment));
        }

        public void UpdateCallbackId()
        {
            __Internal.UpdateCallbackId((__Instance + __PointerAdjustment));
        }

        public static bool operator !=(global::OpenZWave.Msg __op, global::OpenZWave.Msg _other)
        {
            return !(__op == _other);
        }

        public static bool operator ==(global::OpenZWave.Msg __op, global::OpenZWave.Msg _other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool _otherNull = ReferenceEquals(_other, null);
            if (__opNull || _otherNull)
                return __opNull && _otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = _other.__Instance;
            var __ret = __Internal.OperatorEqualEqual(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as global::OpenZWave.Msg;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::OpenZWave.Msg.__Internal*) __Instance).GetHashCode();
        }

        public void SetEncrypted()
        {
            __Internal.SetEncrypted((__Instance + __PointerAdjustment));
        }

        public void SetNonce(byte[] nonce)
        {
            if (nonce == null || nonce.Length != 8)
                throw new ArgumentOutOfRangeException("nonce", "The dimensions of the provided array don't match the required size.");
            __Internal.SetNonce((__Instance + __PointerAdjustment), nonce);
        }

        public void ClearNonce()
        {
            __Internal.ClearNonce((__Instance + __PointerAdjustment));
        }

        public void SetHomeId(uint homeId)
        {
            __Internal.SetHomeId((__Instance + __PointerAdjustment), homeId);
        }

        public byte SendAttempts
        {
            get
            {
                var __ret = __Internal.GetSendAttempts((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetSendAttempts((__Instance + __PointerAdjustment), value);
            }
        }

        public byte MaxSendAttempts
        {
            get
            {
                var __ret = __Internal.GetMaxSendAttempts((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetMaxSendAttempts((__Instance + __PointerAdjustment), value);
            }
        }

        /// <summary>Identifies the Node ID of the &quot;target&quot; node (if any) for this function.</summary>
        /// <returns>Node ID of the target.</returns>
        public byte TargetNodeId
        {
            get
            {
                var __ret = __Internal.GetTargetNodeId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Identifies the Callback ID (if any) for this message.  Callback ID is a value (OpenZWave uses sequential IDs) that</para>
        /// <para>helps the application associate message responses with the original message request.</para>
        /// </summary>
        /// <returns>Callback ID for this message.</returns>
        public byte CallbackId
        {
            get
            {
                var __ret = __Internal.GetCallbackId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Identifies the expected reply type (if any) for this message. The expected reply is a function code...one</para>
        /// <para>of the FUNC_ID... values defined in Defs.h.  Many Z-Wave functions generate responses with the same function code</para>
        /// <para>(for example, a FUNC_ID_ZW_GET_VERSION message generates a FUNC_ID_ZW_GET_VERSION response.  But other functions</para>
        /// <para>generate a different response. FUNC_ID_ZW_SEND_DATA triggers several responses, but ultimately, a &quot;Get&quot; sent with</para>
        /// <para>this function should result in a FUNC_ID_APPLICATION_COMMAND_HANDLER response.</para>
        /// </summary>
        /// <returns>Expected reply (function code) for this message.</returns>
        public byte ExpectedReply
        {
            get
            {
                var __ret = __Internal.GetExpectedReply((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Identifies the expected Command Class ID (if any) for this message.</summary>
        /// <returns>Expected command class ID for this message.</returns>
        public byte ExpectedCommandClassId
        {
            get
            {
                var __ret = __Internal.GetExpectedCommandClassId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>For messages that request a Report for a specified command class, identifies the expected Instance</para>
        /// <para>for the variable being obtained in the report.</para>
        /// </summary>
        /// <returns>Expected Instance value for this message.</returns>
        public byte ExpectedInstance
        {
            get
            {
                var __ret = __Internal.GetExpectedInstance((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>get the LogText Associated with this message</summary>
        /// <returns>the LogText used during the constructor</returns>
        public string LogText
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetLogText(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public uint Length
        {
            get
            {
                var __ret = __Internal.GetLength((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte* Buffer
        {
            get
            {
                var __ret = __Internal.GetBuffer((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string AsString
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetAsString(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public bool IsWakeUpNoMoreInformationCommand
        {
            get
            {
                var __ret = __Internal.IsWakeUpNoMoreInformationCommand((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsNoOperation
        {
            get
            {
                var __ret = __Internal.IsNoOperation((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte SendingCommandClass
        {
            get
            {
                var __ret = __Internal.GetSendingCommandClass((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsEncrypted
        {
            get
            {
                var __ret = __Internal.IsEncrypted((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsNonceRecieved
        {
            get
            {
                var __ret = __Internal.IsNonceRecieved((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a pointer to the driver (interface with a Z-Wave controller)</para>
        /// <para>associated with this node.</para>
        /// </summary>
        public global::OpenZWave.Driver Driver
        {
            get
            {
                var __ret = __Internal.GetDriver((__Instance + __PointerAdjustment));
                global::OpenZWave.Driver __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::OpenZWave.Driver.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::OpenZWave.Driver) global::OpenZWave.Driver.NativeToManagedMap[__ret];
                else global::OpenZWave.Driver.NativeToManagedMap[__ret] = __result0 = (global::OpenZWave.Driver) global::OpenZWave.Driver.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace OpenZWave
{
    public unsafe partial class TimeStampImpl
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.TimeStampImpl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.TimeStampImpl>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.TimeStampImpl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.TimeStampImpl(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.TimeStampImpl __CreateInstance(global::OpenZWave.TimeStampImpl.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.TimeStampImpl(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.TimeStampImpl.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.TimeStampImpl.__Internal));
            *(global::OpenZWave.TimeStampImpl.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TimeStampImpl(global::OpenZWave.TimeStampImpl.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TimeStampImpl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>Implements a platform-independent TimeStamp.</summary>
    public unsafe partial class TimeStamp : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_pImpl;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9TimeStampC2Ev")]
            internal static extern void ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9TimeStampD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9TimeStamp7SetTimeEi")]
            internal static extern void SetTime(global::System.IntPtr instance, int _milliseconds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9TimeStampmiERKS0_")]
            internal static extern int OperatorMinus(global::System.IntPtr instance, global::System.IntPtr _other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9TimeStamp13TimeRemainingEv")]
            internal static extern int TimeRemaining(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9TimeStamp11GetAsStringEv")]
            internal static extern void GetAsString(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.TimeStamp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.TimeStamp>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.TimeStamp __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.TimeStamp(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.TimeStamp __CreateInstance(global::OpenZWave.TimeStamp.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.TimeStamp(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.TimeStamp.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.TimeStamp.__Internal));
            *(global::OpenZWave.TimeStamp.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TimeStamp(global::OpenZWave.TimeStamp.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TimeStamp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        /// <summary>
        /// <para>Constructor.</para>
        /// <para>Creates a TimeStamp object.</para>
        /// </summary>
        public TimeStamp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.TimeStamp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.TimeStamp __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>SetTime.  Sets the timestamp to now, plus the offset in milliseconds.</summary>
        /// <param name="_milliseconds">
        /// <para>optional positive or negative offset from</para>
        /// <para>now in milliseconds.  Defaults to zero.</para>
        /// </param>
        public void SetTime(int _milliseconds)
        {
            __Internal.SetTime((__Instance + __PointerAdjustment), _milliseconds);
        }

        /// <summary>
        /// <para>Overload the subtract operator to get the difference between</para>
        /// <para>two timestamps in milliseconds.</para>
        /// </summary>
        public static int operator -(global::OpenZWave.TimeStamp __op, global::OpenZWave.TimeStamp _other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(_other, null))
                throw new global::System.ArgumentNullException("_other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _other.__Instance;
            var __ret = __Internal.OperatorMinus(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>TimeRemaining.  Gets the difference between now and the timestamp</para>
        /// <para>time in milliseconds.</para>
        /// </summary>
        /// <returns>
        /// <para>milliseconds remaining until we reach the timestamp.  The</para>
        /// <para>return value is negative if the timestamp is in the past.</para>
        /// </returns>
        public int TimeRemaining
        {
            get
            {
                var __ret = __Internal.TimeRemaining((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Return as a string for output.</summary>
        /// <returns>string</returns>
        public string AsString
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetAsString(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace OpenZWave
{
    public unsafe partial class InstanceAssociation : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_nodeId;

            [FieldOffset(1)]
            internal byte m_instance;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave19InstanceAssociationC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.InstanceAssociation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.InstanceAssociation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.InstanceAssociation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.InstanceAssociation(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.InstanceAssociation __CreateInstance(global::OpenZWave.InstanceAssociation.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.InstanceAssociation(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.InstanceAssociation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.InstanceAssociation.__Internal));
            *(global::OpenZWave.InstanceAssociation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private InstanceAssociation(global::OpenZWave.InstanceAssociation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected InstanceAssociation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public InstanceAssociation(global::OpenZWave.InstanceAssociation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.InstanceAssociation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::OpenZWave.InstanceAssociation.__Internal*) __Instance) = *((global::OpenZWave.InstanceAssociation.__Internal*) _0.__Instance);
        }

        public InstanceAssociation()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.InstanceAssociation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.InstanceAssociation __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte MNodeId
        {
            get
            {
                return ((global::OpenZWave.InstanceAssociation.__Internal*) __Instance)->m_nodeId;
            }

            set
            {
                ((global::OpenZWave.InstanceAssociation.__Internal*)__Instance)->m_nodeId = value;
            }
        }

        public byte MInstance
        {
            get
            {
                return ((global::OpenZWave.InstanceAssociation.__Internal*) __Instance)->m_instance;
            }

            set
            {
                ((global::OpenZWave.InstanceAssociation.__Internal*)__Instance)->m_instance = value;
            }
        }
    }

    /// <summary>Manages a group of devices (various nodes associated with each other).</summary>
    public unsafe partial class Group : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_label;

            [FieldOffset(24)]
            internal uint m_homeId;

            [FieldOffset(28)]
            internal byte m_nodeId;

            [FieldOffset(29)]
            internal byte m_groupIdx;

            [FieldOffset(30)]
            internal byte m_maxAssociations;

            [FieldOffset(31)]
            internal byte m_auto;

            [FieldOffset(32)]
            internal byte m_multiInstance;

            [FieldOffset(40)]
            internal global::Std.Map.__Internalc__N_std_N___1_S_map____N_OpenZWave_S_InstanceAssociation___N_std_N___1_S_vector____N_OpenZWave_S_Group_S_AssociationCommand___N_std_N___1_S_allocator__S2____N_OpenZWave_S_Group_S_classcomp___N_std_N___1_S_allocator____N_std_N___1_S_pair__1S0__S1_ m_associations;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5GroupC2Ejhhh")]
            internal static extern void ctor(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx, byte _maxAssociations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5GroupC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5GroupD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5Group15GetAssociationsEPPh")]
            internal static extern uint GetAssociations(global::System.IntPtr instance, byte** o_associations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5Group15GetAssociationsEPPNS_19InstanceAssociationE")]
            internal static extern uint GetAssociations_1(global::System.IntPtr instance, global::System.IntPtr o_associations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5Group8ContainsEhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Contains(global::System.IntPtr instance, byte _nodeId, byte _instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5Group13ClearCommandsEhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ClearCommands(global::System.IntPtr instance, byte _nodeId, byte _instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5Group10AddCommandEhhPKhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddCommand(global::System.IntPtr instance, byte _nodeId, byte _length, byte* _data, byte _instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave5Group8GetLabelEv")]
            internal static extern global::System.IntPtr GetLabel(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave5Group18GetMaxAssociationsEv")]
            internal static extern byte GetMaxAssociations(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave5Group6GetIdxEv")]
            internal static extern byte GetIdx(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Group> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Group>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Group __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Group(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Group __CreateInstance(global::OpenZWave.Group.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Group(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Group.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Group.__Internal));
            global::OpenZWave.Group.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Group(global::OpenZWave.Group.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Group(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Group(uint _homeId, byte _nodeId, byte _groupIdx, byte _maxAssociations)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Group.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx, _maxAssociations);
        }

        public Group(global::OpenZWave.Group _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Group.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Group __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint GetAssociations(byte** o_associations)
        {
            var __ret = __Internal.GetAssociations((__Instance + __PointerAdjustment), o_associations);
            return __ret;
        }

        public uint GetAssociations(global::OpenZWave.InstanceAssociation o_associations)
        {
            var __arg0 = ReferenceEquals(o_associations, null) ? global::System.IntPtr.Zero : o_associations.__Instance;
            var __ret = __Internal.GetAssociations_1((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public bool Contains(byte _nodeId, byte _instance)
        {
            var __ret = __Internal.Contains((__Instance + __PointerAdjustment), _nodeId, _instance);
            return __ret;
        }

        public bool ClearCommands(byte _nodeId, byte _instance)
        {
            var __ret = __Internal.ClearCommands((__Instance + __PointerAdjustment), _nodeId, _instance);
            return __ret;
        }

        public bool AddCommand(byte _nodeId, byte _length, byte* _data, byte _instance)
        {
            var __ret = __Internal.AddCommand((__Instance + __PointerAdjustment), _nodeId, _length, _data, _instance);
            return __ret;
        }

        public string Label
        {
            get
            {
                var __ret = __Internal.GetLabel((__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public byte MaxAssociations
        {
            get
            {
                var __ret = __Internal.GetMaxAssociations((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte Idx
        {
            get
            {
                var __ret = __Internal.GetIdx((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>
    /// <para>The Node class describes a Z-Wave node object...typically a device on the</para>
    /// <para>Z-Wave network.</para>
    /// </summary>
    public unsafe partial class Node : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 704)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_Node;

            [FieldOffset(8)]
            internal global::OpenZWave.Node.QueryStage m_queryStage;

            [FieldOffset(12)]
            internal byte m_queryPending;

            [FieldOffset(13)]
            internal byte m_queryConfiguration;

            [FieldOffset(14)]
            internal byte m_queryRetries;

            [FieldOffset(15)]
            internal byte m_protocolInfoReceived;

            [FieldOffset(16)]
            internal byte m_basicprotocolInfoReceived;

            [FieldOffset(17)]
            internal byte m_nodeInfoReceived;

            [FieldOffset(18)]
            internal byte m_nodePlusInfoReceived;

            [FieldOffset(19)]
            internal byte m_manufacturerSpecificClassReceived;

            [FieldOffset(20)]
            internal byte m_nodeInfoSupported;

            [FieldOffset(21)]
            internal byte m_refreshonNodeInfoFrame;

            [FieldOffset(22)]
            internal byte m_nodeAlive;

            [FieldOffset(23)]
            internal byte m_listening;

            [FieldOffset(24)]
            internal byte m_frequentListening;

            [FieldOffset(25)]
            internal byte m_beaming;

            [FieldOffset(26)]
            internal byte m_routing;

            [FieldOffset(28)]
            internal uint m_maxBaudRate;

            [FieldOffset(32)]
            internal byte m_version;

            [FieldOffset(33)]
            internal byte m_security;

            [FieldOffset(36)]
            internal uint m_homeId;

            [FieldOffset(40)]
            internal byte m_nodeId;

            [FieldOffset(41)]
            internal byte m_basic;

            [FieldOffset(42)]
            internal byte m_generic;

            [FieldOffset(43)]
            internal byte m_specific;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_type;

            [FieldOffset(72)]
            internal fixed byte m_neighbors[29];

            [FieldOffset(101)]
            internal byte m_numRouteNodes;

            [FieldOffset(102)]
            internal fixed byte m_routeNodes[5];

            [FieldOffset(112)]
            internal global::Std.Map.__Internalc__N_std_N___1_S_map__c_c___N_std_N___1_S_less__c___N_std_N___1_S_allocator____N_std_N___1_S_pair__1c_c m_buttonMap;

            [FieldOffset(136)]
            internal byte m_addingNode;

            [FieldOffset(144)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_manufacturerName;

            [FieldOffset(168)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_productName;

            [FieldOffset(192)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_nodeName;

            [FieldOffset(216)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_location;

            [FieldOffset(240)]
            internal ushort m_manufacturerId;

            [FieldOffset(242)]
            internal ushort m_productType;

            [FieldOffset(244)]
            internal ushort m_productId;

            [FieldOffset(246)]
            internal ushort m_deviceType;

            [FieldOffset(248)]
            internal byte m_role;

            [FieldOffset(249)]
            internal byte m_nodeType;

            [FieldOffset(256)]
            internal global::Std.Map.__Internalc__N_std_N___1_S_map__c____N_OpenZWave_S_CommandClass___N_std_N___1_S_less__c___N_std_N___1_S_allocator____N_std_N___1_S_pair__1c_S0_ m_commandClassMap;

            [FieldOffset(280)]
            internal byte m_secured;

            [FieldOffset(288)]
            internal global::System.IntPtr m_values;

            [FieldOffset(296)]
            internal global::Std.Map.__Internalc__N_std_N___1_S_map__c____N_OpenZWave_S_Group___N_std_N___1_S_less__c___N_std_N___1_S_allocator____N_std_N___1_S_pair__1c_S0_ m_groups;

            [FieldOffset(320)]
            internal uint m_sentCnt;

            [FieldOffset(324)]
            internal uint m_sentFailed;

            [FieldOffset(328)]
            internal uint m_retries;

            [FieldOffset(332)]
            internal uint m_receivedCnt;

            [FieldOffset(336)]
            internal uint m_receivedDups;

            [FieldOffset(340)]
            internal uint m_receivedUnsolicited;

            [FieldOffset(344)]
            internal uint m_lastRequestRTT;

            [FieldOffset(348)]
            internal uint m_lastResponseRTT;

            [FieldOffset(352)]
            internal global::OpenZWave.TimeStamp.__Internal m_sentTS;

            [FieldOffset(360)]
            internal global::OpenZWave.TimeStamp.__Internal m_receivedTS;

            [FieldOffset(368)]
            internal uint m_averageRequestRTT;

            [FieldOffset(372)]
            internal uint m_averageResponseRTT;

            [FieldOffset(376)]
            internal byte m_quality;

            [FieldOffset(377)]
            internal fixed byte m_lastReceivedMessage[254];

            [FieldOffset(631)]
            internal byte m_errors;

            [FieldOffset(632)]
            internal byte m_lastnonce;

            [FieldOffset(633)]
            internal fixed byte m_nonces[64];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4NodeC2Ejh")]
            internal static extern void ctor(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4NodeC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node14AdvanceQueriesEv")]
            internal static extern void AdvanceQueries(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node18QueryStageCompleteENS0_10QueryStageE")]
            internal static extern void QueryStageComplete(global::System.IntPtr instance, global::OpenZWave.Node.QueryStage _stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node15QueryStageRetryENS0_10QueryStageEh")]
            internal static extern void QueryStageRetry(global::System.IntPtr instance, global::OpenZWave.Node.QueryStage _stage, byte _maxAttempts);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node13SetQueryStageENS0_10QueryStageEb")]
            internal static extern void SetQueryStage(global::System.IntPtr instance, global::OpenZWave.Node.QueryStage _stage, bool _advance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node17GetQueryStageNameENS0_10QueryStageE")]
            internal static extern void GetQueryStageName(global::System.IntPtr @return, global::System.IntPtr instance, global::OpenZWave.Node.QueryStage _stage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node18UpdateProtocolInfoEPKh")]
            internal static extern void UpdateProtocolInfo(global::System.IntPtr instance, byte* _data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node15SetProtocolInfoEPKhh")]
            internal static extern void SetProtocolInfo(global::System.IntPtr instance, byte* _protocolInfo, byte _length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node14UpdateNodeInfoEPKhh")]
            internal static extern void UpdateNodeInfo(global::System.IntPtr instance, byte* _data, byte _length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node23SetNodePlusInfoReceivedEb")]
            internal static extern void SetNodePlusInfoReceived(global::System.IntPtr instance, bool _received);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node12SetNodeAliveEb")]
            internal static extern void SetNodeAlive(global::System.IntPtr instance, bool _isAlive);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node12GetNeighborsEPPh")]
            internal static extern uint GetNeighbors(global::System.IntPtr instance, byte** o_associations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node13SetAddingNodeEv")]
            internal static extern void SetAddingNode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node15ClearAddingNodeEv")]
            internal static extern void ClearAddingNode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node25ApplicationCommandHandlerEPKhb")]
            internal static extern void ApplicationCommandHandler(global::System.IntPtr instance, byte* _data, bool encrypted);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node17SetSecuredClassesEPKhh")]
            internal static extern void SetSecuredClasses(global::System.IntPtr instance, byte* _data, byte _length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node10SetSecuredEb")]
            internal static extern void SetSecured(global::System.IntPtr instance, bool secure);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node8SetLevelEh")]
            internal static extern void SetLevel(global::System.IntPtr instance, byte _level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node9SetNodeOnEv")]
            internal static extern void SetNodeOn(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node10SetNodeOffEv")]
            internal static extern void SetNodeOff(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node13CreateValueIDENS_7ValueID10ValueGenreEhhhNS1_9ValueTypeE")]
            internal static extern global::OpenZWave.ValueID.__Internal CreateValueID(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::OpenZWave.ValueID.ValueType _type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node11RemoveValueEhhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveValue(global::System.IntPtr instance, byte _commandClassId, byte _instance, byte _valueIndex);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node15CreateValueBoolENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbbh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueBool(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, bool _default, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node17CreateValueButtonENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueButton(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node15CreateValueByteENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueByte(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, byte _default, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node18CreateValueDecimalENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbSB_h")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueDecimal(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, global::System.IntPtr _default, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node14CreateValueIntENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbih")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueInt(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, int _default, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node14CreateValueRawENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbPKhhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueRaw(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, byte* _default, byte _length, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node19CreateValueScheduleENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueSchedule(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node16CreateValueShortENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbsh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueShort(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, short _default, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node17CreateValueStringENS_7ValueID10ValueGenreEhhhRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEESB_bbSB_h")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateValueString(global::System.IntPtr instance, global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::System.IntPtr _label, global::System.IntPtr _units, bool _readOnly, bool _writeOnly, global::System.IntPtr _default, byte _pollIntensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node16GenerateNonceKeyEv")]
            internal static extern byte* GenerateNonceKey(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node11GetNonceKeyEj")]
            internal static extern byte* GetNonceKey(global::System.IntPtr instance, uint nonceid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node20GetCurrentQueryStageEv")]
            internal static extern global::OpenZWave.Node.QueryStage GetCurrentQueryStage(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node11IsNodeAliveEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeAlive(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node20ProtocolInfoReceivedEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ProtocolInfoReceived(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node16NodeInfoReceivedEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool NodeInfoReceived(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node15IsNodeZWavePlusEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeZWavePlus(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node19AllQueriesCompletedEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AllQueriesCompleted(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node17IsListeningDeviceEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsListeningDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node25IsFrequentListeningDeviceEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsFrequentListeningDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node15IsBeamingDeviceEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsBeamingDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node15IsRoutingDeviceEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRoutingDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node16IsSecurityDeviceEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsSecurityDevice(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node14GetMaxBaudRateEv")]
            internal static extern uint GetMaxBaudRate(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node10GetVersionEv")]
            internal static extern byte GetVersion(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node11GetSecurityEv")]
            internal static extern byte GetSecurity(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node9GetNodeIdEv")]
            internal static extern byte GetNodeId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node8GetBasicEv")]
            internal static extern byte GetBasic(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node10GetGenericEv")]
            internal static extern byte GetGeneric(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node11GetSpecificEv")]
            internal static extern byte GetSpecific(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node7GetTypeEv")]
            internal static extern global::System.IntPtr GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node12IsControllerEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsController(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave4Node12IsAddingNodeEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAddingNode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4Node11IsNodeResetEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeReset(global::System.IntPtr instance);
        }

        public enum QueryStage : uint
        {
            /// <summary>Query process hasn't started for this node</summary>
            QueryStageNone = 0,
            /// <summary>Retrieve protocol information</summary>
            QueryStageProtocolInfo = 1,
            /// <summary>Ping device to see if alive</summary>
            QueryStageProbe = 2,
            /// <summary>Start wake up process if a sleeping node</summary>
            QueryStageWakeUp = 3,
            /// <summary>Retrieve manufacturer name and product ids if ProtocolInfo lets us</summary>
            QueryStageManufacturerSpecific1 = 4,
            /// <summary>Retrieve info about supported, controlled command classes</summary>
            QueryStageNodeInfo = 5,
            /// <summary>Retrieve ZWave+ info and update device classes</summary>
            QueryStageNodePlusInfo = 6,
            /// <summary>Retrieve a list of Command Classes that require Security</summary>
            QueryStageSecurityReport = 7,
            /// <summary>Retrieve manufacturer name and product ids</summary>
            QueryStageManufacturerSpecific2 = 8,
            /// <summary>Retrieve version information</summary>
            QueryStageVersions = 9,
            /// <summary>Retrieve information about multiple command class instances</summary>
            QueryStageInstances = 10,
            /// <summary>Retrieve static information (doesn't change)</summary>
            QueryStageStatic = 11,
            /// <summary>Ping a device upon restarting with cached config for the device</summary>
            QueryStageCacheLoad = 12,
            QueryStageProbe1 = 12,
            /// <summary>Retrieve information about associations</summary>
            QueryStageAssociations = 13,
            /// <summary>Retrieve node neighbor list</summary>
            QueryStageNeighbors = 14,
            /// <summary>Retrieve session information (changes infrequently)</summary>
            QueryStageSession = 15,
            /// <summary>Retrieve dynamic information (changes frequently)</summary>
            QueryStageDynamic = 16,
            /// <summary>Retrieve configurable parameter information (only done on request)</summary>
            QueryStageConfiguration = 17,
            /// <summary>Query process is completed for this node</summary>
            QueryStageComplete = 18
        }

        [Flags]
        public enum SecurityFlag : uint
        {
            SecurityFlagSecurity = 0x1,
            SecurityFlagController = 0x2,
            SecurityFlagSpecificDevice = 0x4,
            SecurityFlagRoutingSlave = 0x8,
            SecurityFlagBeamCapability = 0x10,
            SecurityFlagSensor250ms = 0x20,
            SecurityFlagSensor1000ms = 0x40,
            SecurityFlagOptionalFunctionality = 0x80
        }

        public enum NodeBroadcast : uint
        {
            NodeBroadcast = 0xff
        }

        public unsafe partial class NodeData : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 368)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint m_sentCnt;

                [FieldOffset(4)]
                internal uint m_sentFailed;

                [FieldOffset(8)]
                internal uint m_retries;

                [FieldOffset(12)]
                internal uint m_receivedCnt;

                [FieldOffset(16)]
                internal uint m_receivedDups;

                [FieldOffset(20)]
                internal uint m_receivedUnsolicited;

                [FieldOffset(24)]
                internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_sentTS;

                [FieldOffset(48)]
                internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_receivedTS;

                [FieldOffset(72)]
                internal uint m_lastRequestRTT;

                [FieldOffset(76)]
                internal uint m_averageRequestRTT;

                [FieldOffset(80)]
                internal uint m_lastResponseRTT;

                [FieldOffset(84)]
                internal uint m_averageResponseRTT;

                [FieldOffset(88)]
                internal byte m_quality;

                [FieldOffset(89)]
                internal fixed byte m_lastReceivedMessage[254];

                [FieldOffset(344)]
                internal global::Std.List.__Internalc__N_std_N___1_S_list____N_OpenZWave_S_Node_S_CommandClassData___N_std_N___1_S_allocator__S0_ m_ccData;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave4Node8NodeDataC2ERKS1_")]
                internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave4Node8NodeDataC2Ev")]
                internal static extern void ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave4Node8NodeDataD2Ev")]
                internal static extern void dtor(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Node.NodeData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Node.NodeData>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::OpenZWave.Node.NodeData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::OpenZWave.Node.NodeData(native.ToPointer(), skipVTables);
            }

            internal static global::OpenZWave.Node.NodeData __CreateInstance(global::OpenZWave.Node.NodeData.__Internal native, bool skipVTables = false)
            {
                return new global::OpenZWave.Node.NodeData(native, skipVTables);
            }

            private static void* __CopyValue(global::OpenZWave.Node.NodeData.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.NodeData.__Internal));
                global::OpenZWave.Node.NodeData.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private NodeData(global::OpenZWave.Node.NodeData.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NodeData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public NodeData(global::OpenZWave.Node.NodeData _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.NodeData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public NodeData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.NodeData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::OpenZWave.Node.NodeData __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment));
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint MSentCnt
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_sentCnt;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_sentCnt = value;
                }
            }

            public uint MSentFailed
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_sentFailed;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_sentFailed = value;
                }
            }

            public uint MRetries
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_retries;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_retries = value;
                }
            }

            public uint MReceivedCnt
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_receivedCnt;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_receivedCnt = value;
                }
            }

            public uint MReceivedDups
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_receivedDups;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_receivedDups = value;
                }
            }

            public uint MReceivedUnsolicited
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_receivedUnsolicited;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_receivedUnsolicited = value;
                }
            }

            public string MSentTS
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_sentTS));
                    var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                    __basicStringRet0.Dispose(false);
                    return __stringRet0;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_sentTS = *(global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C*) __basicString0.__Instance;
                }
            }

            public string MReceivedTS
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_receivedTS));
                    var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                    __basicStringRet0.Dispose(false);
                    return __stringRet0;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_receivedTS = *(global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C*) __basicString0.__Instance;
                }
            }

            public uint MLastRequestRTT
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_lastRequestRTT;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_lastRequestRTT = value;
                }
            }

            public uint MAverageRequestRTT
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_averageRequestRTT;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_averageRequestRTT = value;
                }
            }

            public uint MLastResponseRTT
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_lastResponseRTT;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_lastResponseRTT = value;
                }
            }

            public uint MAverageResponseRTT
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_averageResponseRTT;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_averageResponseRTT = value;
                }
            }

            public byte MQuality
            {
                get
                {
                    return ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_quality;
                }

                set
                {
                    ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_quality = value;
                }
            }

            public byte[] MLastReceivedMessage
            {
                get
                {
                    byte[] __value = null;
                    if (((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_lastReceivedMessage != null)
                    {
                        __value = new byte[254];
                        for (int i = 0; i < 254; i++)
                            __value[i] = ((global::OpenZWave.Node.NodeData.__Internal*) __Instance)->m_lastReceivedMessage[i];
                    }
                    return __value;
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 254; i++)
                            ((global::OpenZWave.Node.NodeData.__Internal*)__Instance)->m_lastReceivedMessage[i] = value[i];
                    }
                }
            }
        }

        public unsafe partial class CommandClassData : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal byte m_commandClassId;

                [FieldOffset(4)]
                internal uint m_sentCnt;

                [FieldOffset(8)]
                internal uint m_receivedCnt;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN9OpenZWave4Node16CommandClassDataC2ERKS1_")]
                internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Node.CommandClassData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Node.CommandClassData>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::OpenZWave.Node.CommandClassData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::OpenZWave.Node.CommandClassData(native.ToPointer(), skipVTables);
            }

            internal static global::OpenZWave.Node.CommandClassData __CreateInstance(global::OpenZWave.Node.CommandClassData.__Internal native, bool skipVTables = false)
            {
                return new global::OpenZWave.Node.CommandClassData(native, skipVTables);
            }

            private static void* __CopyValue(global::OpenZWave.Node.CommandClassData.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.CommandClassData.__Internal));
                *(global::OpenZWave.Node.CommandClassData.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private CommandClassData(global::OpenZWave.Node.CommandClassData.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CommandClassData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CommandClassData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.CommandClassData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public CommandClassData(global::OpenZWave.Node.CommandClassData _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.CommandClassData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::OpenZWave.Node.CommandClassData.__Internal*) __Instance) = *((global::OpenZWave.Node.CommandClassData.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::OpenZWave.Node.CommandClassData __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public byte MCommandClassId
            {
                get
                {
                    return ((global::OpenZWave.Node.CommandClassData.__Internal*) __Instance)->m_commandClassId;
                }

                set
                {
                    ((global::OpenZWave.Node.CommandClassData.__Internal*)__Instance)->m_commandClassId = value;
                }
            }

            public uint MSentCnt
            {
                get
                {
                    return ((global::OpenZWave.Node.CommandClassData.__Internal*) __Instance)->m_sentCnt;
                }

                set
                {
                    ((global::OpenZWave.Node.CommandClassData.__Internal*)__Instance)->m_sentCnt = value;
                }
            }

            public uint MReceivedCnt
            {
                get
                {
                    return ((global::OpenZWave.Node.CommandClassData.__Internal*) __Instance)->m_receivedCnt;
                }

                set
                {
                    ((global::OpenZWave.Node.CommandClassData.__Internal*)__Instance)->m_receivedCnt = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Node> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Node>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Node __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Node(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Node __CreateInstance(global::OpenZWave.Node.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Node(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Node.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.__Internal));
            global::OpenZWave.Node.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Node(global::OpenZWave.Node.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Node(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        /// <summary>
        /// <para>Constructor initializes the node object, associating it with a specific</para>
        /// <para>network (_homeId) and network node (_nodeId).</para>
        /// </summary>
        /// <param name="_homeId">The homeId of the network to which this node is connected.</param>
        /// <param name="_nodeId">The nodeId of this node.</param>
        public Node(uint _homeId, byte _nodeId)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment), _homeId, _nodeId);
            SetupVTables(GetType().FullName == "OpenZWave.Node");
        }

        public Node(global::OpenZWave.Node _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Node.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "OpenZWave.Node");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Node __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::OpenZWave.Node.__Internal*) __Instance)->vptr_Node = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                var ___dtorDelegate = (global::OpenZWave.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr));
                ___dtorDelegate((__Instance + __PointerAdjustment));
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>This function advances the query process (see Remarks below for more detail on the</para>
        /// <para>process).  It iterates through the various query stages enumerated in Node::QueryStage.</para>
        /// </summary>
        /// <remarks>
        /// <para>For OpenZWave to discover everything about a node, we have to follow a certain</para>
        /// <para>order of queries, because the results of one stage may affect what is requested</para>
        /// <para>in the next stage.  The stage is saved with the node data, so that any incomplete</para>
        /// <para>queries can be restarted the next time the application runs.</para>
        /// <para></para>
        /// <para>The individual command classes also store some state information as to whether</para>
        /// <para>they have had a response to certain queries.  This state information is</para>
        /// <para>initialized by the SetStaticRequests call in QueryStage_None.  It is also saved,</para>
        /// <para>so we do not need to request state  from every command class if some have previously</para>
        /// <para>responded.</para>
        /// </remarks>
        public void AdvanceQueries()
        {
            __Internal.AdvanceQueries((__Instance + __PointerAdjustment));
        }

        /// <summary>
        /// <para>Signal that a specific query stage has been completed for this node.  This will</para>
        /// <para>only work if the query process for this node is indeed at the specified stage.</para>
        /// <para>Otherwise, the function returns with no action.</para>
        /// </summary>
        /// <param name="_stage">The current stage of the query process.</param>
        public void QueryStageComplete(global::OpenZWave.Node.QueryStage _stage)
        {
            __Internal.QueryStageComplete((__Instance + __PointerAdjustment), _stage);
        }

        /// <summary>
        /// <para>Retry the specified query stage (up to _maxAttempts retries).  This will</para>
        /// <para>only work if the query process for this node is indeed at the specified stage.</para>
        /// <para>Otherwise, the function returns with no action.</para>
        /// </summary>
        /// <param name="_stage">The query stage to retry.</param>
        public void QueryStageRetry(global::OpenZWave.Node.QueryStage _stage, byte _maxAttempts)
        {
            __Internal.QueryStageRetry((__Instance + __PointerAdjustment), _stage, _maxAttempts);
        }

        /// <summary>
        /// <para>This function sets the query stage for the node (but only to an earlier stage).</para>
        /// <para>If a later stage is specified than the current one, it is ignored.</para>
        /// </summary>
        /// <param name="_stage">The desired query stage.</param>
        /// <remarks>m_queryStage, m_queryPending</remarks>
        public void SetQueryStage(global::OpenZWave.Node.QueryStage _stage, bool _advance)
        {
            __Internal.SetQueryStage((__Instance + __PointerAdjustment), _stage, _advance);
        }

        /// <summary>Returns the specified query stage string.</summary>
        /// <param name="_stage">The query stage.</param>
        /// <returns>Specified query stage string.</returns>
        /// <remarks>m_queryStage, m_queryPending</remarks>
        public string GetQueryStageName(global::OpenZWave.Node.QueryStage _stage)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetQueryStageName(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _stage);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>This function handles a response to the FUNC_ID_ZW_GET_NODE_PROTOCOL_INFO</para>
        /// <para>command for this node.  If protocol information has already been retrieved</para>
        /// <para>for the node, the function simply returns.  Otherwise, it populates several</para>
        /// <para>member variables about the device at this node:</para>
        /// <para>- m_routing (whether it is a routing node (capable of passing commands along to other nodes in the network) or not</para>
        /// <para>- m_maxBaudRate (the maximum baud rate at which this device can communicate)</para>
        /// <para>- m_version (TODO)</para>
        /// <para>- m_security (whether device supports security features)</para>
        /// <para>- m_listening (device is powered and listening constantly)</para>
        /// <para>- m_frequentListening (device can be woken up with a beam)</para>
        /// <para>- m_beaming (device is beam capable)</para>
        /// </summary>
        public void UpdateProtocolInfo(byte* _data)
        {
            __Internal.UpdateProtocolInfo((__Instance + __PointerAdjustment), _data);
        }

        /// <summary>
        /// <para>this function is called when the Node is added via a AddNode request. the ProtocolInfo field contains the</para>
        /// <para>devices classes and the CommandClasses that the node supports, so we can build a pretty good Node out of that</para>
        /// <para>info.</para>
        /// </summary>
        /// <param name="_protocolInfo">Byte 0 - Basic Device Class Byte 1 - Generic Device Class, Byte 2 - Specific Device Classes Remaining Bytes - Supported Command Classes</param>
        /// <param name="_length">length of the _protocolInfo field.</param>
        public void SetProtocolInfo(byte* _protocolInfo, byte _length)
        {
            __Internal.SetProtocolInfo((__Instance + __PointerAdjustment), _protocolInfo, _length);
        }

        public void UpdateNodeInfo(byte* _data, byte _length)
        {
            __Internal.UpdateNodeInfo((__Instance + __PointerAdjustment), _data, _length);
        }

        public void SetNodePlusInfoReceived(bool _received)
        {
            __Internal.SetNodePlusInfoReceived((__Instance + __PointerAdjustment), _received);
        }

        /// <summary>
        /// <para>Handle dead node detection tracking.</para>
        /// <para>Use this routine to set state of nodes.</para>
        /// <para>Tracks state as well as send notifications.</para>
        /// </summary>
        public void SetNodeAlive(bool _isAlive)
        {
            __Internal.SetNodeAlive((__Instance + __PointerAdjustment), _isAlive);
        }

        public uint GetNeighbors(byte** o_associations)
        {
            var __ret = __Internal.GetNeighbors((__Instance + __PointerAdjustment), o_associations);
            return __ret;
        }

        public void SetAddingNode()
        {
            __Internal.SetAddingNode((__Instance + __PointerAdjustment));
        }

        public void ClearAddingNode()
        {
            __Internal.ClearAddingNode((__Instance + __PointerAdjustment));
        }

        public void ApplicationCommandHandler(byte* _data, bool encrypted)
        {
            __Internal.ApplicationCommandHandler((__Instance + __PointerAdjustment), _data, encrypted);
        }

        /// <summary>
        /// <para>This function sets up Secured Command Classes. It iterates over the existing command classes marking them</para>
        /// <para>as Secured if they exist, and if they don't, it creates new Command Classes and sets them up as Secured</para>
        /// </summary>
        /// <param name="_data">a list of Command Classes that are Secured by the Device</param>
        /// <param name="_length">the length of the _data string</param>
        public void SetSecuredClasses(byte* _data, byte _length)
        {
            __Internal.SetSecuredClasses((__Instance + __PointerAdjustment), _data, _length);
        }

        public void SetSecured(bool secure)
        {
            __Internal.SetSecured((__Instance + __PointerAdjustment), secure);
        }

        public void SetLevel(byte _level)
        {
            __Internal.SetLevel((__Instance + __PointerAdjustment), _level);
        }

        public void SetNodeOn()
        {
            __Internal.SetNodeOn((__Instance + __PointerAdjustment));
        }

        public void SetNodeOff()
        {
            __Internal.SetNodeOff((__Instance + __PointerAdjustment));
        }

        public global::OpenZWave.ValueID CreateValueID(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, global::OpenZWave.ValueID.ValueType _type)
        {
            var __ret = __Internal.CreateValueID((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, _type);
            return global::OpenZWave.ValueID.__CreateInstance(__ret);
        }

        public bool RemoveValue(byte _commandClassId, byte _instance, byte _valueIndex)
        {
            var __ret = __Internal.RemoveValue((__Instance + __PointerAdjustment), _commandClassId, _instance, _valueIndex);
            return __ret;
        }

        public bool CreateValueBool(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, bool _default, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __ret = __Internal.CreateValueBool((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, _default, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            return __ret;
        }

        public bool CreateValueButton(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __ret = __Internal.CreateValueButton((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            return __ret;
        }

        public bool CreateValueByte(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, byte _default, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __ret = __Internal.CreateValueByte((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, _default, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            return __ret;
        }

        public bool CreateValueDecimal(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, string _default, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __allocator8 = new global::Std.Allocator<sbyte>();
            var __basicString8 = global::Std.BasicStringExtensions.BasicString(_default, __allocator8);
            var __arg8 = __basicString8.__Instance;
            var __ret = __Internal.CreateValueDecimal((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, __arg8, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            __basicString8.Dispose(false);
            __allocator8.Dispose();
            return __ret;
        }

        public bool CreateValueInt(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, int _default, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __ret = __Internal.CreateValueInt((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, _default, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            return __ret;
        }

        public bool CreateValueRaw(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, byte* _default, byte _length, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __ret = __Internal.CreateValueRaw((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, _default, _length, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            return __ret;
        }

        public bool CreateValueSchedule(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __ret = __Internal.CreateValueSchedule((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            return __ret;
        }

        public bool CreateValueShort(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, short _default, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __ret = __Internal.CreateValueShort((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, _default, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            return __ret;
        }

        public bool CreateValueString(global::OpenZWave.ValueID.ValueGenre _genre, byte _commandClassId, byte _instance, byte _valueIndex, string _label, string _units, bool _readOnly, bool _writeOnly, string _default, byte _pollIntensity)
        {
            var __allocator4 = new global::Std.Allocator<sbyte>();
            var __basicString4 = global::Std.BasicStringExtensions.BasicString(_label, __allocator4);
            var __arg4 = __basicString4.__Instance;
            var __allocator5 = new global::Std.Allocator<sbyte>();
            var __basicString5 = global::Std.BasicStringExtensions.BasicString(_units, __allocator5);
            var __arg5 = __basicString5.__Instance;
            var __allocator8 = new global::Std.Allocator<sbyte>();
            var __basicString8 = global::Std.BasicStringExtensions.BasicString(_default, __allocator8);
            var __arg8 = __basicString8.__Instance;
            var __ret = __Internal.CreateValueString((__Instance + __PointerAdjustment), _genre, _commandClassId, _instance, _valueIndex, __arg4, __arg5, _readOnly, _writeOnly, __arg8, _pollIntensity);
            __basicString4.Dispose(false);
            __allocator4.Dispose();
            __basicString5.Dispose(false);
            __allocator5.Dispose();
            __basicString8.Dispose(false);
            __allocator8.Dispose();
            return __ret;
        }

        public byte* GenerateNonceKey()
        {
            var __ret = __Internal.GenerateNonceKey((__Instance + __PointerAdjustment));
            return __ret;
        }

        public byte* GetNonceKey(uint nonceid)
        {
            var __ret = __Internal.GetNonceKey((__Instance + __PointerAdjustment), nonceid);
            return __ret;
        }

        /// <summary>Returns the current query stage enum.</summary>
        /// <returns>Enum value with the current query stage.</returns>
        /// <remarks>m_queryStage</remarks>
        public global::OpenZWave.Node.QueryStage CurrentQueryStage
        {
            get
            {
                var __ret = __Internal.GetCurrentQueryStage((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Returns whether the library thinks a node is functioning properly</summary>
        /// <returns>boolean status of node.</returns>
        public bool IsNodeAlive
        {
            get
            {
                var __ret = __Internal.IsNodeAlive((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool ProtocolInfoReceived
        {
            get
            {
                var __ret = __Internal.ProtocolInfoReceived((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool NodeInfoReceived
        {
            get
            {
                var __ret = __Internal.NodeInfoReceived((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsNodeZWavePlus
        {
            get
            {
                var __ret = __Internal.IsNodeZWavePlus((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool AllQueriesCompleted
        {
            get
            {
                var __ret = __Internal.AllQueriesCompleted((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsListeningDevice
        {
            get
            {
                var __ret = __Internal.IsListeningDevice((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsFrequentListeningDevice
        {
            get
            {
                var __ret = __Internal.IsFrequentListeningDevice((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsBeamingDevice
        {
            get
            {
                var __ret = __Internal.IsBeamingDevice((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsRoutingDevice
        {
            get
            {
                var __ret = __Internal.IsRoutingDevice((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsSecurityDevice
        {
            get
            {
                var __ret = __Internal.IsSecurityDevice((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public uint MaxBaudRate
        {
            get
            {
                var __ret = __Internal.GetMaxBaudRate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte Version
        {
            get
            {
                var __ret = __Internal.GetVersion((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte Security
        {
            get
            {
                var __ret = __Internal.GetSecurity((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte NodeId
        {
            get
            {
                var __ret = __Internal.GetNodeId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte Basic
        {
            get
            {
                var __ret = __Internal.GetBasic((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte Generic
        {
            get
            {
                var __ret = __Internal.GetGeneric((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public byte Specific
        {
            get
            {
                var __ret = __Internal.GetSpecific((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public string Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        public bool IsController
        {
            get
            {
                var __ret = __Internal.IsController((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsAddingNode
        {
            get
            {
                var __ret = __Internal.IsAddingNode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsNodeReset
        {
            get
            {
                var __ret = __Internal.IsNodeReset((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~Node()
        private static global::OpenZWave.Delegates.Action_IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.Node) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(4 * 8);
                    var vfptr0 = vtptr + 2 * 8;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -16);
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(4 * 8);
                    var vfptr0 = vtptr + 2 * 8;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -16);
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }
}

namespace OpenZWave
{
}

namespace OpenZWave
{
}

namespace OpenZWave
{
    public unsafe partial class SerialPort
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.SerialPort> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.SerialPort>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.SerialPort __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.SerialPort(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.SerialPort __CreateInstance(global::OpenZWave.SerialPort.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.SerialPort(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.SerialPort.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.SerialPort.__Internal));
            *(global::OpenZWave.SerialPort.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SerialPort(global::OpenZWave.SerialPort.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SerialPort(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    /// <summary>The main public interface to OpenZWave.</summary>
    /// <remarks>
    /// <para>A singleton class providing the main public interface to OpenZWave.</para>
    /// <para>The Manager class exposes all the functionality required to add</para>
    /// <para>Z-Wave support to an application.  It handles the sending and receiving</para>
    /// <para>of Z-Wave messages as well as the configuration of a Z-Wave network</para>
    /// <para>and its devices, freeing the library user from the burden of learning</para>
    /// <para>the low-level details of the Z-Wave protocol.</para>
    /// <para></para>
    /// <para>All Z-Wave functionality is accessed via the Manager class.  While this</para>
    /// <para>does not make for the most efficient code structure, it does enable</para>
    /// <para>the library to handle potentially complex and hard-to-debug issues</para>
    /// <para>such as multi-threading and object lifespans behind the scenes.</para>
    /// <para>Application development is therefore simplified and less prone to bugs.</para>
    /// <para></para>
    /// <para>There can be only one instance of the Manager class, and all applications</para>
    /// <para>will start by calling Manager::Create static method to create that instance.</para>
    /// <para>From then on, a call to the Manager::Get static method will return the</para>
    /// <para>pointer to the Manager object.  On application exit, Manager::Destroy</para>
    /// <para>should be called to allow OpenZWave to clean up and delete any other</para>
    /// <para>objects it has created.</para>
    /// <para></para>
    /// <para>Once the Manager has been created, a call should be made to Manager::AddWatcher</para>
    /// <para>to install a notification callback handler.  This handler will receive</para>
    /// <para>notifications of Z-Wave network changes and updates to device values, and is</para>
    /// <para>an essential element of OpenZWave.</para>
    /// <para></para>
    /// <para>Next, a call should be made to Manager::AddDriver for each Z-Wave controller</para>
    /// <para>attached to the PC.  Each Driver will handle the sending and receiving of</para>
    /// <para>messages for all the devices in its controller's Z-Wave network.  The Driver</para>
    /// <para>will read any previously saved configuration and then query the Z-Wave controller</para>
    /// <para>for any missing information.  Once that process is complete, a DriverReady</para>
    /// <para>notification callback will be sent containing the Home ID of the controller,</para>
    /// <para>which is required by most of the other Manager class methods.</para>
    /// <para></para>
    /// <para>[After the DriverReady notification is sent, the Driver will poll each node on</para>
    /// <para>the network to update information about each node.  After all &quot;awake&quot; nodes</para>
    /// <para>have been polled, an &quot;AllAwakeNodesQueried&quot; notification is sent.  This is when</para>
    /// <para>a client application can expect all of the node information (both static</para>
    /// <para>information, like the physical device's capabilities, session information</para>
    /// <para>(like [associations and/or names] and dynamic information (like temperature or</para>
    /// <para>on/off state) to be available.  Finally, after all nodes (whether listening or</para>
    /// <para>sleeping) have been polled, an &quot;AllNodesQueried&quot; notification is sent.]</para>
    /// </remarks>
    public unsafe partial class Manager : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_Manager;

            [FieldOffset(8)]
            internal byte m_exit;

            [FieldOffset(16)]
            internal global::System.IntPtr m_options;

            [FieldOffset(24)]
            internal global::Std.List.__Internalc__N_std_N___1_S_list_____N_OpenZWave_S_Driver___N_std_N___1_S_allocator__S0_ m_pendingDrivers;

            [FieldOffset(48)]
            internal global::Std.Map.__Internalc__N_std_N___1_S_map__i____N_OpenZWave_S_Driver___N_std_N___1_S_less__i___N_std_N___1_S_allocator____N_std_N___1_S_pair__1i_S0_ m_readyDrivers;

            [FieldOffset(72)]
            internal global::Std.List.__Internalc__N_std_N___1_S_list_____N_OpenZWave_S_Manager_S_Watcher___N_std_N___1_S_allocator__S0_ m_watchers;

            [FieldOffset(96)]
            internal global::Std.List.__Internalc__N_std_N___1_S_list_____N_std_N___1_S___list_iterator_____N_OpenZWave_S_Manager_S_Watcher__v___N_std_N___1_S_allocator__S0_ m_watcherIterators;

            [FieldOffset(120)]
            internal global::System.IntPtr m_notificationMutex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7ManagerC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager6CreateEv")]
            internal static extern global::System.IntPtr Create();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager3GetEv")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager7DestroyEv")]
            internal static extern void Destroy();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11WriteConfigEj")]
            internal static extern void WriteConfig(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager9AddDriverERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS_6Driver19ControllerInterfaceE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddDriver(global::System.IntPtr instance, global::System.IntPtr _controllerPath, global::OpenZWave.Driver.ControllerInterface* _interface);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12RemoveDriverERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveDriver(global::System.IntPtr instance, global::System.IntPtr _controllerPath);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19GetControllerNodeIdEj")]
            internal static extern byte GetControllerNodeId(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12GetSUCNodeIdEj")]
            internal static extern byte GetSUCNodeId(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19IsPrimaryControllerEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPrimaryController(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager24IsStaticUpdateControllerEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsStaticUpdateController(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18IsBridgeControllerEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsBridgeController(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetLibraryVersionEj")]
            internal static extern void GetLibraryVersion(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18GetLibraryTypeNameEj")]
            internal static extern void GetLibraryTypeName(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetSendQueueCountEj")]
            internal static extern int GetSendQueueCount(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19LogDriverStatisticsEj")]
            internal static extern void LogDriverStatistics(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26GetControllerInterfaceTypeEj")]
            internal static extern global::OpenZWave.Driver.ControllerInterface GetControllerInterfaceType(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetControllerPathEj")]
            internal static extern void GetControllerPath(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15SetPollIntervalEib")]
            internal static extern void SetPollInterval(global::System.IntPtr instance, int _milliseconds, bool _bIntervalBetweenPolls);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager10EnablePollERKNS_7ValueIDEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool EnablePoll(global::System.IntPtr instance, global::System.IntPtr _valueId, byte _intensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11DisablePollERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DisablePoll(global::System.IntPtr instance, global::System.IntPtr _valueId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8isPolledERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPolled(global::System.IntPtr instance, global::System.IntPtr _valueId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16SetPollIntensityERKNS_7ValueIDEh")]
            internal static extern void SetPollIntensity(global::System.IntPtr instance, global::System.IntPtr _valueId, byte _intensity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16GetPollIntensityERKNS_7ValueIDE")]
            internal static extern byte GetPollIntensity(global::System.IntPtr instance, global::System.IntPtr _valueId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15RefreshNodeInfoEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RefreshNodeInfo(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16RequestNodeStateEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RequestNodeState(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18RequestNodeDynamicEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RequestNodeDynamic(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21IsNodeListeningDeviceEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeListeningDevice(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager29IsNodeFrequentListeningDeviceEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeFrequentListeningDevice(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19IsNodeBeamingDeviceEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeBeamingDevice(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19IsNodeRoutingDeviceEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeRoutingDevice(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager20IsNodeSecurityDeviceEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeSecurityDevice(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18GetNodeMaxBaudRateEjh")]
            internal static extern uint GetNodeMaxBaudRate(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14GetNodeVersionEjh")]
            internal static extern byte GetNodeVersion(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetNodeSecurityEjh")]
            internal static extern byte GetNodeSecurity(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15IsNodeZWavePlusEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeZWavePlus(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12GetNodeBasicEjh")]
            internal static extern byte GetNodeBasic(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14GetNodeGenericEjh")]
            internal static extern byte GetNodeGeneric(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetNodeSpecificEjh")]
            internal static extern byte GetNodeSpecific(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11GetNodeTypeEjh")]
            internal static extern void GetNodeType(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16GetNodeNeighborsEjhPPh")]
            internal static extern uint GetNodeNeighbors(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte** _nodeNeighbors);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager23GetNodeManufacturerNameEjh")]
            internal static extern void GetNodeManufacturerName(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18GetNodeProductNameEjh")]
            internal static extern void GetNodeProductName(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11GetNodeNameEjh")]
            internal static extern void GetNodeName(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetNodeLocationEjh")]
            internal static extern void GetNodeLocation(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21GetNodeManufacturerIdEjh")]
            internal static extern void GetNodeManufacturerId(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18GetNodeProductTypeEjh")]
            internal static extern void GetNodeProductType(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16GetNodeProductIdEjh")]
            internal static extern void GetNodeProductId(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager23SetNodeManufacturerNameEjhRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern void SetNodeManufacturerName(global::System.IntPtr instance, uint _homeId, byte _nodeId, global::System.IntPtr _manufacturerName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18SetNodeProductNameEjhRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern void SetNodeProductName(global::System.IntPtr instance, uint _homeId, byte _nodeId, global::System.IntPtr _productName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11SetNodeNameEjhRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern void SetNodeName(global::System.IntPtr instance, uint _homeId, byte _nodeId, global::System.IntPtr _nodeName);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15SetNodeLocationEjhRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern void SetNodeLocation(global::System.IntPtr instance, uint _homeId, byte _nodeId, global::System.IntPtr _location);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager9SetNodeOnEjh")]
            internal static extern void SetNodeOn(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager10SetNodeOffEjh")]
            internal static extern void SetNodeOff(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12SetNodeLevelEjhh")]
            internal static extern void SetNodeLevel(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _level);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18IsNodeInfoReceivedEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeInfoReceived(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager23GetNodeClassInformationEjhhPNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetNodeClassInformation(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _commandClassId, global::System.IntPtr _className, byte* _classVersion);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11IsNodeAwakeEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeAwake(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12IsNodeFailedEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNodeFailed(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetNodeQueryStageEjh")]
            internal static extern void GetNodeQueryStage(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetNodeDeviceTypeEjh")]
            internal static extern ushort GetNodeDeviceType(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager23GetNodeDeviceTypeStringEjh")]
            internal static extern void GetNodeDeviceTypeString(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11GetNodeRoleEjh")]
            internal static extern byte GetNodeRole(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetNodeRoleStringEjh")]
            internal static extern void GetNodeRoleString(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetNodePlusTypeEjh")]
            internal static extern byte GetNodePlusType(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21GetNodePlusTypeStringEjh")]
            internal static extern void GetNodePlusTypeString(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13GetValueLabelERKNS_7ValueIDE")]
            internal static extern void GetValueLabel(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetValueLabelERKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            internal static extern void SetValueLabel(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13GetValueUnitsERKNS_7ValueIDE")]
            internal static extern void GetValueUnits(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetValueUnitsERKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            internal static extern void SetValueUnits(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12GetValueHelpERKNS_7ValueIDE")]
            internal static extern void GetValueHelp(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12SetValueHelpERKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            internal static extern void SetValueHelp(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11GetValueMinERKNS_7ValueIDE")]
            internal static extern int GetValueMin(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11GetValueMaxERKNS_7ValueIDE")]
            internal static extern int GetValueMax(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15IsValueReadOnlyERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsValueReadOnly(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16IsValueWriteOnlyERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsValueWriteOnly(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager10IsValueSetERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsValueSet(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13IsValuePolledERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsValuePolled(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14GetValueAsBoolERKNS_7ValueIDEPb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsBool(global::System.IntPtr instance, global::System.IntPtr _id, bool* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14GetValueAsByteERKNS_7ValueIDEPh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsByte(global::System.IntPtr instance, global::System.IntPtr _id, byte* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetValueAsFloatERKNS_7ValueIDEPf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsFloat(global::System.IntPtr instance, global::System.IntPtr _id, float* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13GetValueAsIntERKNS_7ValueIDEPi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsInt(global::System.IntPtr instance, global::System.IntPtr _id, int* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetValueAsShortERKNS_7ValueIDEPs")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsShort(global::System.IntPtr instance, global::System.IntPtr _id, short* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16GetValueAsStringERKNS_7ValueIDEPNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsString(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13GetValueAsRawERKNS_7ValueIDEPPhS4_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueAsRaw(global::System.IntPtr instance, global::System.IntPtr _id, byte** o_value, byte* o_length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21GetValueListSelectionERKNS_7ValueIDEPNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueListSelection(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21GetValueListSelectionERKNS_7ValueIDEPi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueListSelection(global::System.IntPtr instance, global::System.IntPtr _id, int* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager22GetValueFloatPrecisionERKNS_7ValueIDEPh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetValueFloatPrecision(global::System.IntPtr instance, global::System.IntPtr _id, byte* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDEb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue(global::System.IntPtr instance, global::System.IntPtr _id, bool _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue_1(global::System.IntPtr instance, global::System.IntPtr _id, byte _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDEf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue_2(global::System.IntPtr instance, global::System.IntPtr _id, float _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDEi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue_3(global::System.IntPtr instance, global::System.IntPtr _id, int _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDEs")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue_4(global::System.IntPtr instance, global::System.IntPtr _id, short _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDEPKhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue(global::System.IntPtr instance, global::System.IntPtr _id, byte* _value, byte _length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager8SetValueERKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValue(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21SetValueListSelectionERKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetValueListSelection(global::System.IntPtr instance, global::System.IntPtr _id, global::System.IntPtr _selectedItem);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12RefreshValueERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RefreshValue(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17SetChangeVerifiedERKNS_7ValueIDEb")]
            internal static extern void SetChangeVerified(global::System.IntPtr instance, global::System.IntPtr _id, bool _verify);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetChangeVerifiedERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetChangeVerified(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11PressButtonERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PressButton(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13ReleaseButtonERKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ReleaseButton(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18GetNumSwitchPointsERKNS_7ValueIDE")]
            internal static extern byte GetNumSwitchPoints(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14SetSwitchPointERKNS_7ValueIDEhha")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSwitchPoint(global::System.IntPtr instance, global::System.IntPtr _id, byte _hours, byte _minutes, sbyte _setback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17RemoveSwitchPointERKNS_7ValueIDEhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveSwitchPoint(global::System.IntPtr instance, global::System.IntPtr _id, byte _hours, byte _minutes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17ClearSwitchPointsERKNS_7ValueIDE")]
            internal static extern void ClearSwitchPoints(global::System.IntPtr instance, global::System.IntPtr _id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14GetSwitchPointERKNS_7ValueIDEhPhS4_Pa")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetSwitchPoint(global::System.IntPtr instance, global::System.IntPtr _id, byte _idx, byte* o_hours, byte* o_minutes, sbyte* o_setback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11SwitchAllOnEj")]
            internal static extern void SwitchAllOn(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12SwitchAllOffEj")]
            internal static extern void SwitchAllOff(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14SetConfigParamEjhhih")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetConfigParam(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _param, int _value, byte _size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18RequestConfigParamEjhh")]
            internal static extern void RequestConfigParam(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _param);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager22RequestAllConfigParamsEjh")]
            internal static extern void RequestAllConfigParams(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12GetNumGroupsEjh")]
            internal static extern byte GetNumGroups(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetAssociationsEjhhPPh")]
            internal static extern uint GetAssociations(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx, byte** o_associations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetAssociationsEjhhPPNS_19InstanceAssociationE")]
            internal static extern uint GetAssociations_1(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx, global::System.IntPtr o_associations);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18GetMaxAssociationsEjhh")]
            internal static extern byte GetMaxAssociations(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13GetGroupLabelEjhh")]
            internal static extern void GetGroupLabel(global::System.IntPtr @return, global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager14AddAssociationEjhhhh")]
            internal static extern void AddAssociation(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx, byte _targetNodeId, byte _instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17RemoveAssociationEjhhhh")]
            internal static extern void RemoveAssociation(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _groupIdx, byte _targetNodeId, byte _instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager10AddWatcherEPFvPKNS_12NotificationEPvES4_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddWatcher(global::System.IntPtr instance, global::System.IntPtr _watcher, global::System.IntPtr _context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13RemoveWatcherEPFvPKNS_12NotificationEPvES4_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveWatcher(global::System.IntPtr instance, global::System.IntPtr _watcher, global::System.IntPtr _context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15ResetControllerEj")]
            internal static extern void ResetController(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager9SoftResetEj")]
            internal static extern void SoftReset(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager22BeginControllerCommandEjNS_6Driver17ControllerCommandEPFvNS1_15ControllerStateENS1_15ControllerErrorEPvES5_bhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginControllerCommand(global::System.IntPtr instance, uint _homeId, global::OpenZWave.Driver.ControllerCommand _command, global::System.IntPtr _callback, global::System.IntPtr _context, bool _highPower, byte _nodeId, byte _arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager23CancelControllerCommandEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CancelControllerCommand(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15TestNetworkNodeEjhj")]
            internal static extern void TestNetworkNode(global::System.IntPtr instance, uint _homeId, byte _nodeId, uint _count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11TestNetworkEjj")]
            internal static extern void TestNetwork(global::System.IntPtr instance, uint _homeId, uint _count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15HealNetworkNodeEjhb")]
            internal static extern void HealNetworkNode(global::System.IntPtr instance, uint _homeId, byte _nodeId, bool _doRR);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11HealNetworkEjb")]
            internal static extern void HealNetwork(global::System.IntPtr instance, uint _homeId, bool _doRR);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager7AddNodeEjb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddNode(global::System.IntPtr instance, uint _homeId, bool _doSecurity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager10RemoveNodeEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveNode(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16RemoveFailedNodeEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveFailedNode(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13HasNodeFailedEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasNodeFailed(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager25RequestNodeNeighborUpdateEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RequestNodeNeighborUpdate(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17AssignReturnRouteEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AssignReturnRoute(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21DeleteAllReturnRoutesEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeleteAllReturnRoutes(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19SendNodeInformationEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SendNodeInformation(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16CreateNewPrimaryEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateNewPrimary(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager20ReceiveConfigurationEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ReceiveConfiguration(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17ReplaceFailedNodeEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ReplaceFailedNode(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19TransferPrimaryRoleEj")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TransferPrimaryRole(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager20RequestNetworkUpdateEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RequestNetworkUpdate(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15ReplicationSendEjh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ReplicationSend(global::System.IntPtr instance, uint _homeId, byte _nodeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12CreateButtonEjhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CreateButton(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _buttonid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12DeleteButtonEjhh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DeleteButton(global::System.IntPtr instance, uint _homeId, byte _nodeId, byte _buttonid);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12GetAllScenesEPPh")]
            internal static extern byte GetAllScenes(global::System.IntPtr instance, byte** _sceneIds);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15RemoveAllScenesEj")]
            internal static extern void RemoveAllScenes(global::System.IntPtr instance, uint _homeId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11CreateSceneEv")]
            internal static extern byte CreateScene(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11RemoveSceneEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveScene(global::System.IntPtr instance, byte _sceneId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13AddSceneValueEhRKNS_7ValueIDEb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValue(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, bool _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13AddSceneValueEhRKNS_7ValueIDEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValue_1(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, byte _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13AddSceneValueEhRKNS_7ValueIDEf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValue_2(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, float _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13AddSceneValueEhRKNS_7ValueIDEi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValue_3(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, int _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13AddSceneValueEhRKNS_7ValueIDEs")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValue_4(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, short _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13AddSceneValueEhRKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValue(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26AddSceneValueListSelectionEhRKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValueListSelection(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26AddSceneValueListSelectionEhRKNS_7ValueIDEi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddSceneValueListSelection(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, int _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager16RemoveSceneValueEhRKNS_7ValueIDE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RemoveSceneValue(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19SceneGetValueAsBoolEhRKNS_7ValueIDEPb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueAsBool(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, bool* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19SceneGetValueAsByteEhRKNS_7ValueIDEPh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueAsByte(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, byte* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager20SceneGetValueAsFloatEhRKNS_7ValueIDEPf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueAsFloat(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, float* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18SceneGetValueAsIntEhRKNS_7ValueIDEPi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueAsInt(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, int* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager20SceneGetValueAsShortEhRKNS_7ValueIDEPs")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueAsShort(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, short* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager21SceneGetValueAsStringEhRKNS_7ValueIDEPNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueAsString(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, global::System.IntPtr o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26SceneGetValueListSelectionEhRKNS_7ValueIDEPNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueListSelection(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, global::System.IntPtr o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26SceneGetValueListSelectionEhRKNS_7ValueIDEPi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneGetValueListSelection(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, int* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneValueEhRKNS_7ValueIDEb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValue(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, bool _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneValueEhRKNS_7ValueIDEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValue_1(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, byte _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneValueEhRKNS_7ValueIDEf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValue_2(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, float _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneValueEhRKNS_7ValueIDEi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValue_3(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, int _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneValueEhRKNS_7ValueIDEs")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValue_4(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, short _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneValueEhRKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValue(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26SetSceneValueListSelectionEhRKNS_7ValueIDERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValueListSelection(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager26SetSceneValueListSelectionEhRKNS_7ValueIDEi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetSceneValueListSelection(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _valueId, int _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13GetSceneLabelEh")]
            internal static extern void GetSceneLabel(global::System.IntPtr @return, global::System.IntPtr instance, byte _sceneId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13SetSceneLabelEhRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern void SetSceneLabel(global::System.IntPtr instance, byte _sceneId, global::System.IntPtr _value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager11SceneExistsEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SceneExists(global::System.IntPtr instance, byte _sceneId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager13ActivateSceneEh")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ActivateScene(global::System.IntPtr instance, byte _sceneId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager19GetDriverStatisticsEjPNS_6Driver10DriverDataE")]
            internal static extern void GetDriverStatistics(global::System.IntPtr instance, uint _homeId, global::System.IntPtr _data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager17GetNodeStatisticsEjhPNS_4Node8NodeDataE")]
            internal static extern void GetNodeStatistics(global::System.IntPtr instance, uint _homeId, byte _nodeId, global::System.IntPtr _data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager15GetPollIntervalEv")]
            internal static extern int GetPollInterval(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager18getVersionAsStringEv")]
            internal static extern void GetVersionAsString(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager22getVersionLongAsStringEv")]
            internal static extern void GetVersionLongAsString(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7Manager10GetOptionsEv")]
            internal static extern global::System.IntPtr GetOptions(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Manager12GetNumScenesEv")]
            internal static extern byte GetNumScenes(global::System.IntPtr instance);
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void PfnOnNotificationT(global::System.IntPtr _pNotification, global::System.IntPtr _context);

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Manager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Manager>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Manager __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Manager(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Manager __CreateInstance(global::OpenZWave.Manager.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Manager(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Manager.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Manager.__Internal));
            global::OpenZWave.Manager.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Manager(global::OpenZWave.Manager.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Manager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Manager(global::OpenZWave.Manager _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Manager.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Manager __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Saves the configuration of a PC Controller's Z-Wave network to the application's user data folder.</para>
        /// <para>This method does not normally need to be called, since OpenZWave will save the state automatically</para>
        /// <para>during the shutdown process.  It is provided here only as an aid to development.</para>
        /// <para>The configuration of each PC Controller's Z-Wave network is stored in a separate file.  The filename</para>
        /// <para>consists of the 8 digit hexadecimal version of the controller's Home ID, prefixed with the string 'zwcfg_'.</para>
        /// <para>This convention allows OpenZWave to find the correct configuration file for a controller, even if it is</para>
        /// <para>attached to a different serial port, USB device path, etc.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller to save.</param>
        public void WriteConfig(uint _homeId)
        {
            __Internal.WriteConfig((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>
        /// <para>Creates a new driver for a Z-Wave controller.</para>
        /// <para>This method creates a Driver object for handling communications with a single Z-Wave controller.  In the background, the</para>
        /// <para>driver first tries to read configuration data saved during a previous run.  It then queries the controller directly for any</para>
        /// <para>missing information, and a refresh of the list of nodes that it controls.  Once this information</para>
        /// <para>has been received, a DriverReady notification callback is sent, containing the Home ID of the controller.  This Home ID is</para>
        /// <para>required by most of the OpenZWave Manager class methods.</para>
        /// </summary>
        /// <param name="_controllerPath">
        /// <para>The string used to open the controller.  On Windows this might be something like</para>
        /// <para>&quot;\.&quot;, or on Linux &quot;/dev/ttyUSB0&quot;.</para>
        /// </param>
        /// <returns>True if a new driver was created, false if a driver for the controller already exists.</returns>
        /// <remarks>Create, Get, RemoveDriver</remarks>
        public bool AddDriver(string _controllerPath, global::OpenZWave.Driver.ControllerInterface* _interface)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_controllerPath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.AddDriver((__Instance + __PointerAdjustment), __arg0, _interface);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>
        /// <para>Removes the driver for a Z-Wave controller, and closes the controller.</para>
        /// <para>Drivers do not need to be explicitly removed before calling Destroy - this is handled automatically.</para>
        /// </summary>
        /// <param name="_controllerPath">The same string as was passed in the original call to AddDriver.</param>
        /// <remarks>
        /// <para>You should NOT call any Manager methods that require the Driver Reference (eg, in response to</para>
        /// <para>Notifications received about NodeRemoved etc) once you call this, as your application will most likely</para>
        /// <para>break</para>
        /// <para>True if the driver was removed, false if it could not be found.</para>
        /// <para>Destroy, AddDriver</para>
        /// </remarks>
        public bool RemoveDriver(string _controllerPath)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_controllerPath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.RemoveDriver((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Get the node ID of the Z-Wave controller.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>the node ID of the Z-Wave controller.</returns>
        public byte GetControllerNodeId(uint _homeId)
        {
            var __ret = __Internal.GetControllerNodeId((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>Get the node ID of the Static Update Controller.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>the node ID of the Z-Wave controller.</returns>
        public byte GetSUCNodeId(uint _homeId)
        {
            var __ret = __Internal.GetSUCNodeId((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Query if the controller is a primary controller.</para>
        /// <para>The primary controller is the main device used to configure and control a Z-Wave network.</para>
        /// <para>There can only be one primary controller - all other controllers are secondary controllers.</para>
        /// <para></para>
        /// <para>The only difference between a primary and secondary controller is that the primary is the</para>
        /// <para>only one that can be used to add or remove other devices.  For this reason, it is usually</para>
        /// <para>better for the primary controller to be portable, since most devices must be added when</para>
        /// <para>installed in their final location.</para>
        /// <para></para>
        /// <para>Calls to BeginControllerCommand will fail if the controller is not the primary.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>true if it is a primary controller, false if not.</returns>
        public bool IsPrimaryController(uint _homeId)
        {
            var __ret = __Internal.IsPrimaryController((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Query if the controller is a static update controller.</para>
        /// <para>A Static Update Controller (SUC) is a controller that must never be moved in normal operation</para>
        /// <para>and which can be used by other nodes to receive information about network changes.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>true if it is a static update controller, false if not.</returns>
        public bool IsStaticUpdateController(uint _homeId)
        {
            var __ret = __Internal.IsStaticUpdateController((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Query if the controller is using the bridge controller library.</para>
        /// <para>A bridge controller is able to create virtual nodes that can be associated</para>
        /// <para>with other controllers to enable events to be passed on.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>true if it is a bridge controller, false if not.</returns>
        public bool IsBridgeController(uint _homeId)
        {
            var __ret = __Internal.IsBridgeController((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>Get the version of the Z-Wave API library used by a controller.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>a string containing the library version. For example, &quot;Z-Wave 2.48&quot;.</returns>
        public string GetLibraryVersion(uint _homeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetLibraryVersion(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get a string containing the Z-Wave API library type used by a controller.</para>
        /// <para>The possible library types are:</para>
        /// <para>- Static Controller</para>
        /// <para>- Controller</para>
        /// <para>- Enhanced Slave</para>
        /// <para>- Slave</para>
        /// <para>- Installer</para>
        /// <para>- Routing Slave</para>
        /// <para>- Bridge Controller</para>
        /// <para>- Device Under Test</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>a string containing the library type.</returns>
        /// <remarks>
        /// <para>The controller should never return a slave library type.</para>
        /// <para>For a more efficient test of whether a controller is a Bridge Controller, use</para>
        /// <para>the IsBridgeController method.</para>
        /// <para>GetLibraryVersion, IsBridgeController</para>
        /// </remarks>
        public string GetLibraryTypeName(uint _homeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetLibraryTypeName(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get count of messages in the outgoing send queue.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>a integer message count</returns>
        public int GetSendQueueCount(uint _homeId)
        {
            var __ret = __Internal.GetSendQueueCount((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>Send current driver statistics to the log file</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        public void LogDriverStatistics(uint _homeId)
        {
            __Internal.LogDriverStatistics((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>Obtain controller interface type</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        public global::OpenZWave.Driver.ControllerInterface GetControllerInterfaceType(uint _homeId)
        {
            var __ret = __Internal.GetControllerInterfaceType((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>Obtain controller interface path</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        public string GetControllerPath(uint _homeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetControllerPath(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Set the time period between polls of a node's state.</para>
        /// <para>Due to patent concerns, some devices do not report state changes automatically to the controller.</para>
        /// <para>These devices need to have their state polled at regular intervals.  The length of the interval</para>
        /// <para>is the same for all devices.  To even out the Z-Wave network traffic generated by polling, OpenZWave</para>
        /// <para>divides the polling interval by the number of devices that have polling enabled, and polls each</para>
        /// <para>in turn.  It is recommended that if possible, the interval should not be set shorter than the</para>
        /// <para>number of polled devices in seconds (so that the network does not have to cope with more than one</para>
        /// <para>poll per second).</para>
        /// </summary>
        /// <param name="_seconds">The length of the polling interval in seconds.</param>
        public void SetPollInterval(int _milliseconds, bool _bIntervalBetweenPolls)
        {
            __Internal.SetPollInterval((__Instance + __PointerAdjustment), _milliseconds, _bIntervalBetweenPolls);
        }

        /// <summary>Enable the polling of a device's state.</summary>
        /// <param name="_valueId">The ID of the value to start polling.</param>
        /// <param name="_intensity,">number of polling for one polling interval.</param>
        /// <returns>True if polling was enabled.</returns>
        public bool EnablePoll(global::OpenZWave.ValueID _valueId, byte _intensity)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _valueId.__Instance;
            var __ret = __Internal.EnablePoll((__Instance + __PointerAdjustment), __arg0, _intensity);
            return __ret;
        }

        /// <summary>Disable the polling of a device's state.</summary>
        /// <param name="_valueId">The ID of the value to stop polling.</param>
        /// <returns>True if polling was disabled.</returns>
        public bool DisablePoll(global::OpenZWave.ValueID _valueId)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _valueId.__Instance;
            var __ret = __Internal.DisablePoll((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Determine the polling of a device's state.</summary>
        /// <param name="_valueId">The ID of the value to check polling.</param>
        /// <returns>True if polling is active.</returns>
        public bool IsPolled(global::OpenZWave.ValueID _valueId)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _valueId.__Instance;
            var __ret = __Internal.IsPolled((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Set the frequency of polling (0=none, 1=every time through the list, 2-every other time, etc)</summary>
        /// <param name="_valueId">The ID of the value whose intensity should be set</param>
        public void SetPollIntensity(global::OpenZWave.ValueID _valueId, byte _intensity)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _valueId.__Instance;
            __Internal.SetPollIntensity((__Instance + __PointerAdjustment), __arg0, _intensity);
        }

        /// <summary>Get the polling intensity of a device's state.</summary>
        /// <param name="_valueId">The ID of the value to check polling.</param>
        /// <returns>Intensity, number of polling for one polling interval.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public byte GetPollIntensity(global::OpenZWave.ValueID _valueId)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _valueId.__Instance;
            var __ret = __Internal.GetPollIntensity((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Trigger the fetching of fixed data about a node.</para>
        /// <para>Causes the node's data to be obtained from the Z-Wave network in the same way as if it had just been added.</para>
        /// <para>This method would normally be called automatically by OpenZWave, but if you know that a node has been</para>
        /// <para>changed, calling this method will force a refresh of all of the data held by the library.  This can be especially</para>
        /// <para>useful for devices that were asleep when the application was first run. This is the</para>
        /// <para>same as the query state starting from the beginning.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the request was sent successfully.</returns>
        public bool RefreshNodeInfo(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.RefreshNodeInfo((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Trigger the fetching of dynamic value data for a node.</para>
        /// <para>Causes the node's values to be requested from the Z-Wave network. This is the</para>
        /// <para>same as the query state starting from the associations state.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the request was sent successfully.</returns>
        public bool RequestNodeState(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.RequestNodeState((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Trigger the fetching of just the dynamic value data for a node.</para>
        /// <para>Causes the node's values to be requested from the Z-Wave network. This is the</para>
        /// <para>same as the query state starting from the dynamic state.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the request was sent successfully.</returns>
        public bool RequestNodeDynamic(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.RequestNodeDynamic((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get whether the node is a listening device that does not go to sleep</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if it is a listening node.</returns>
        public bool IsNodeListeningDevice(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeListeningDevice((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Get whether the node is a frequent listening device that goes to sleep but</para>
        /// <para>can be woken up by a beam. Useful to determine node and controller consistency.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if it is a frequent listening node.</returns>
        public bool IsNodeFrequentListeningDevice(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeFrequentListeningDevice((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get whether the node is a beam capable device.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if it is a beam capable node.</returns>
        public bool IsNodeBeamingDevice(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeBeamingDevice((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get whether the node is a routing device that passes messages to other nodes</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the node is a routing device</returns>
        public bool IsNodeRoutingDevice(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeRoutingDevice((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the security attribute for a node. True if node supports security features.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>true if security features implemented.</returns>
        public bool IsNodeSecurityDevice(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeSecurityDevice((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the maximum baud rate of a node's communications</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the baud rate in bits per second.</returns>
        public uint GetNodeMaxBaudRate(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeMaxBaudRate((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the version number of a node</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's version number</returns>
        public byte GetNodeVersion(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeVersion((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the security byte of a node</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's security byte</returns>
        public byte GetNodeSecurity(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeSecurity((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Is this a ZWave+ Supported Node?</summary>
        /// <param name="_homeId">the HomeID of the Z-Wave controller that managed the node.</param>
        /// <param name="_nodeId">the ID of the node to query.</param>
        /// <returns>If this node is a Z-Wave Plus Node</returns>
        public bool IsNodeZWavePlus(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeZWavePlus((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the basic type of a node.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's basic type.</returns>
        public byte GetNodeBasic(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeBasic((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the generic type of a node.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's generic type.</returns>
        public byte GetNodeGeneric(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeGeneric((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the specific type of a node.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's specific type.</returns>
        public byte GetNodeSpecific(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeSpecific((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Get a human-readable label describing the node</para>
        /// <para>The label is taken from the Z-Wave specific, generic or basic type, depending on which of those values are specified by the node.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>A string containing the label text.</returns>
        public string GetNodeType(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeType(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get the bitmap of this node's neighbors</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <param name="_nodeNeighbors">An array of 29 uint8s to hold the neighbor bitmap</param>
        public uint GetNodeNeighbors(uint _homeId, byte _nodeId, byte** _nodeNeighbors)
        {
            var __ret = __Internal.GetNodeNeighbors((__Instance + __PointerAdjustment), _homeId, _nodeId, _nodeNeighbors);
            return __ret;
        }

        /// <summary>
        /// <para>Get the manufacturer name of a device</para>
        /// <para>The manufacturer name would normally be handled by the Manufacturer Specific command class,</para>
        /// <para>taking the manufacturer ID reported by the device and using it to look up the name from the</para>
        /// <para>manufacturer_specific.xml file in the OpenZWave config folder.</para>
        /// <para>However, there are some devices that do not support the command class, so to enable the user</para>
        /// <para>to manually set the name, it is stored with the node data and accessed via this method rather</para>
        /// <para>than being reported via a command class Value object.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>A string containing the node's manufacturer name.</returns>
        /// <remarks>SetNodeManufacturerName, GetNodeProductName, SetNodeProductName</remarks>
        public string GetNodeManufacturerName(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeManufacturerName(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get the product name of a device</para>
        /// <para>The product name would normally be handled by the Manufacturer Specific command class,</para>
        /// <para>taking the product Type and ID reported by the device and using it to look up the name from the</para>
        /// <para>manufacturer_specific.xml file in the OpenZWave config folder.</para>
        /// <para>However, there are some devices that do not support the command class, so to enable the user</para>
        /// <para>to manually set the name, it is stored with the node data and accessed via this method rather</para>
        /// <para>than being reported via a command class Value object.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>A string containing the node's product name.</returns>
        /// <remarks>SetNodeProductName, GetNodeManufacturerName, SetNodeManufacturerName</remarks>
        public string GetNodeProductName(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeProductName(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get the name of a node</para>
        /// <para>The node name is a user-editable label for the node that would normally be handled by the</para>
        /// <para>Node Naming command class, but many devices do not support it.  So that a node can always</para>
        /// <para>be named, OpenZWave stores it with the node data, and provides access through this method</para>
        /// <para>and SetNodeName, rather than reporting it via a command class Value object.</para>
        /// <para>The maximum length of a node name is 16 characters.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>A string containing the node's name.</returns>
        /// <remarks>SetNodeName, GetNodeLocation, SetNodeLocation</remarks>
        public string GetNodeName(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeName(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get the location of a node</para>
        /// <para>The node location is a user-editable string that would normally be handled by the Node Naming</para>
        /// <para>command class, but many devices do not support it.  So that a node can always report its</para>
        /// <para>location, OpenZWave stores it with the node data, and provides access through this method</para>
        /// <para>and SetNodeLocation, rather than reporting it via a command class Value object.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>A string containing the node's location.</returns>
        /// <remarks>SetNodeLocation, GetNodeName, SetNodeName</remarks>
        public string GetNodeLocation(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeLocation(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get the manufacturer ID of a device</para>
        /// <para>The manufacturer ID is a four digit hex code and would normally be handled by the Manufacturer</para>
        /// <para>Specific command class, but not all devices support it.  Although the value reported by this</para>
        /// <para>method will be an empty string if the command class is not supported and cannot be set by the</para>
        /// <para>user, the manufacturer ID is still stored with the node data (rather than being reported via a</para>
        /// <para>command class Value object) to retain a consistent approach with the other manufacturer specific data.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>
        /// <para>A string containing the node's manufacturer ID, or an empty string if the manufacturer</para>
        /// <para>specific command class is not supported by the device.</para>
        /// </returns>
        /// <remarks>
        /// <para>GetNodeProductType, GetNodeProductId, GetNodeManufacturerName, GetNodeProductName</para>
        /// <para>Change the return to uint16 in 2.0 time frame</para>
        /// </remarks>
        public string GetNodeManufacturerId(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeManufacturerId(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get the product type of a device</para>
        /// <para>The product type is a four digit hex code and would normally be handled by the Manufacturer Specific</para>
        /// <para>command class, but not all devices support it.  Although the value reported by this method will</para>
        /// <para>be an empty string if the command class is not supported and cannot be set by the user, the product</para>
        /// <para>type is still stored with the node data (rather than being reported via a command class Value object)</para>
        /// <para>to retain a consistent approach with the other manufacturer specific data.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>
        /// <para>A string containing the node's product type, or an empty string if the manufacturer</para>
        /// <para>specific command class is not supported by the device.</para>
        /// </returns>
        /// <remarks>
        /// <para>GetNodeManufacturerId, GetNodeProductId, GetNodeManufacturerName, GetNodeProductName</para>
        /// <para>Change the return to uint16 in 2.0 time frame</para>
        /// </remarks>
        public string GetNodeProductType(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeProductType(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Get the product ID of a device</para>
        /// <para>The product ID is a four digit hex code and would normally be handled by the Manufacturer Specific</para>
        /// <para>command class, but not all devices support it.  Although the value reported by this method will</para>
        /// <para>be an empty string if the command class is not supported and cannot be set by the user, the product</para>
        /// <para>ID is still stored with the node data (rather than being reported via a command class Value object)</para>
        /// <para>to retain a consistent approach with the other manufacturer specific data.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>
        /// <para>A string containing the node's product ID, or an empty string if the manufacturer</para>
        /// <para>specific command class is not supported by the device.</para>
        /// </returns>
        /// <remarks>
        /// <para>GetNodeManufacturerId, GetNodeProductType, GetNodeManufacturerName, GetNodeProductName</para>
        /// <para>Change the return to uint16 in 2.0 time frame</para>
        /// </remarks>
        public string GetNodeProductId(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeProductId(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Set the manufacturer name of a device</para>
        /// <para>The manufacturer name would normally be handled by the Manufacturer Specific command class,</para>
        /// <para>taking the manufacturer ID reported by the device and using it to look up the name from the</para>
        /// <para>manufacturer_specific.xml file in the OpenZWave config folder.</para>
        /// <para>However, there are some devices that do not support the command class, so to enable the user</para>
        /// <para>to manually set the name, it is stored with the node data and accessed via this method rather</para>
        /// <para>than being reported via a command class Value object.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <param name="_manufacturerName">A string containing the node's manufacturer name.</param>
        /// <remarks>GetNodeManufacturerName, GetNodeProductName, SetNodeProductName</remarks>
        public void SetNodeManufacturerName(uint _homeId, byte _nodeId, string _manufacturerName)
        {
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_manufacturerName, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetNodeManufacturerName((__Instance + __PointerAdjustment), _homeId, _nodeId, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        /// <summary>
        /// <para>Set the product name of a device</para>
        /// <para>The product name would normally be handled by the Manufacturer Specific command class,</para>
        /// <para>taking the product Type and ID reported by the device and using it to look up the name from the</para>
        /// <para>manufacturer_specific.xml file in the OpenZWave config folder.</para>
        /// <para>However, there are some devices that do not support the command class, so to enable the user</para>
        /// <para>to manually set the name, it is stored with the node data and accessed via this method rather</para>
        /// <para>than being reported via a command class Value object.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <param name="_productName">A string containing the node's product name.</param>
        /// <remarks>GetNodeProductName, GetNodeManufacturerName, SetNodeManufacturerName</remarks>
        public void SetNodeProductName(uint _homeId, byte _nodeId, string _productName)
        {
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_productName, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetNodeProductName((__Instance + __PointerAdjustment), _homeId, _nodeId, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        /// <summary>
        /// <para>Set the name of a node</para>
        /// <para>The node name is a user-editable label for the node that would normally be handled by the</para>
        /// <para>Node Naming command class, but many devices do not support it.  So that a node can always</para>
        /// <para>be named, OpenZWave stores it with the node data, and provides access through this method</para>
        /// <para>and GetNodeName, rather than reporting it via a command class Value object.</para>
        /// <para>If the device does support the Node Naming command class, the new name will be sent to the node.</para>
        /// <para>The maximum length of a node name is 16 characters.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <param name="_nodeName">A string containing the node's name.</param>
        /// <remarks>GetNodeName, GetNodeLocation, SetNodeLocation</remarks>
        public void SetNodeName(uint _homeId, byte _nodeId, string _nodeName)
        {
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_nodeName, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetNodeName((__Instance + __PointerAdjustment), _homeId, _nodeId, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        /// <summary>
        /// <para>Set the location of a node</para>
        /// <para>The node location is a user-editable string that would normally be handled by the Node Naming</para>
        /// <para>command class, but many devices do not support it.  So that a node can always report its</para>
        /// <para>location, OpenZWave stores it with the node data, and provides access through this method</para>
        /// <para>and GetNodeLocation, rather than reporting it via a command class Value object.</para>
        /// <para>If the device does support the Node Naming command class, the new location will be sent to the node.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <param name="_location">A string containing the node's location.</param>
        /// <remarks>GetNodeLocation, GetNodeName, SetNodeName</remarks>
        public void SetNodeLocation(uint _homeId, byte _nodeId, string _location)
        {
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_location, __allocator2);
            var __arg2 = __basicString2.__Instance;
            __Internal.SetNodeLocation((__Instance + __PointerAdjustment), _homeId, _nodeId, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
        }

        /// <summary>
        /// <para>Turns a node on</para>
        /// <para>This is a helper method to simplify basic control of a node.  It is the equivalent of</para>
        /// <para>changing the level reported by the node's Basic command class to 255, and will generate a</para>
        /// <para>ValueChanged notification from that class.  This command will turn on the device at its</para>
        /// <para>last known level, if supported by the device, otherwise it will turn	it on at 100%.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to be changed.</param>
        /// <remarks>SetNodeOff, SetNodeLevel</remarks>
        public void SetNodeOn(uint _homeId, byte _nodeId)
        {
            __Internal.SetNodeOn((__Instance + __PointerAdjustment), _homeId, _nodeId);
        }

        /// <summary>
        /// <para>Turns a node off</para>
        /// <para>This is a helper method to simplify basic control of a node.  It is the equivalent of</para>
        /// <para>changing the level reported by the node's Basic command class to zero, and will generate</para>
        /// <para>a ValueChanged notification from that class.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to be changed.</param>
        /// <remarks>SetNodeOn, SetNodeLevel</remarks>
        public void SetNodeOff(uint _homeId, byte _nodeId)
        {
            __Internal.SetNodeOff((__Instance + __PointerAdjustment), _homeId, _nodeId);
        }

        /// <summary>
        /// <para>Sets the basic level of a node</para>
        /// <para>This is a helper method to simplify basic control of a node.  It is the equivalent of</para>
        /// <para>changing the value reported by the node's Basic command class and will generate a</para>
        /// <para>ValueChanged notification from that class.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to be changed.</param>
        /// <param name="_level">
        /// <para>The level to set the node.  Valid values are 0-99 and 255.  Zero is off and</para>
        /// <para>99 is fully on.  255 will turn on the device at its last known level (if supported).</para>
        /// </param>
        /// <remarks>SetNodeOn, SetNodeOff</remarks>
        public void SetNodeLevel(uint _homeId, byte _nodeId, byte _level)
        {
            __Internal.SetNodeLevel((__Instance + __PointerAdjustment), _homeId, _nodeId, _level);
        }

        /// <summary>Get whether the node information has been received</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the node information has been received yet</returns>
        public bool IsNodeInfoReceived(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeInfoReceived((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get whether the node has the defined class available or not</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <param name="_commandClassId">Id of the class to test for</param>
        /// <returns>True if the node does have the class instantiated, will return name&amp;version</returns>
        public bool GetNodeClassInformation(uint _homeId, byte _nodeId, byte _commandClassId, string _className, byte* _classVersion)
        {
            var __arg3 = global::Std.BasicStringExtensions.BasicString(_className, new global::Std.Allocator<sbyte>()).__Instance;
            var __ret = __Internal.GetNodeClassInformation((__Instance + __PointerAdjustment), _homeId, _nodeId, _commandClassId, __arg3, _classVersion);
            return __ret;
        }

        /// <summary>Get whether the node is awake or asleep</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the node is awake</returns>
        public bool IsNodeAwake(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeAwake((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get whether the node is working or has failed</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>True if the node has failed and is no longer part of the network</returns>
        public bool IsNodeFailed(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.IsNodeFailed((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get whether the node's query stage as a string</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>name of current query stage as a string.</returns>
        public string GetNodeQueryStage(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeQueryStage(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get the node device type as reported in the Z-Wave+ Info report.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's DeviceType</returns>
        public ushort GetNodeDeviceType(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeDeviceType((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the node device type as reported in the Z-Wave+ Info report.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's Device Type as a string.</returns>
        public string GetNodeDeviceTypeString(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeDeviceTypeString(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get the node role as reported in the Z-Wave+ Info report.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's user icon.</returns>
        public byte GetNodeRole(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodeRole((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the node role as reported in the Z-Wave+ Info report.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's role type as a string</returns>
        public string GetNodeRoleString(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodeRoleString(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Get the node PlusType as reported in the Z-Wave+ Info report.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's PlusType</returns>
        public byte GetNodePlusType(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNodePlusType((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Get the node PlusType as reported in the Z-Wave+ Info report.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to query.</param>
        /// <returns>the node's PlusType as a string</returns>
        public string GetNodePlusTypeString(uint _homeId, byte _nodeId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetNodePlusTypeString(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Gets the user-friendly label for the value.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>The value label.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public string GetValueLabel(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetValueLabel(new IntPtr(&__ret), (__Instance + __PointerAdjustment), __arg0);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Sets the user-friendly label for the value.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="_value">The new value of the label.</param>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public void SetValueLabel(global::OpenZWave.ValueID _id, string _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.SetValueLabel((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Gets the units that the value is measured in.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>The value units.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public string GetValueUnits(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetValueUnits(new IntPtr(&__ret), (__Instance + __PointerAdjustment), __arg0);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Sets the units that the value is measured in.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="_value">The new value of the units.</param>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public void SetValueUnits(global::OpenZWave.ValueID _id, string _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.SetValueUnits((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Gets a help string describing the value's purpose and usage.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>The value help text.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public string GetValueHelp(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetValueHelp(new IntPtr(&__ret), (__Instance + __PointerAdjustment), __arg0);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Sets a help string describing the value's purpose and usage.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="_value">The new value of the help text.</param>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public void SetValueHelp(global::OpenZWave.ValueID _id, string _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.SetValueHelp((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Gets the minimum that this value may contain.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>The value minimum.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public int GetValueMin(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetValueMin((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets the maximum that this value may contain.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>The value maximum.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public int GetValueMax(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetValueMax((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Test whether the value is read-only.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>true if the value cannot be changed by the user.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public bool IsValueReadOnly(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.IsValueReadOnly((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Test whether the value is write-only.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>true if the value can only be written to and not read.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public bool IsValueWriteOnly(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.IsValueWriteOnly((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Test whether the value has been set.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>true if the value has actually been set by a status message from the device, rather than simply being the default.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public bool IsValueSet(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.IsValueSet((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Test whether the value is currently being polled.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <returns>true if the value is being polled, otherwise false.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID</para>
        /// </remarks>
        public bool IsValuePolled(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.IsValuePolled((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Gets a value as a bool.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a bool that will be filled with the value.</param>
        /// <returns>true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Bool. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsBool(global::OpenZWave.ValueID _id, ref bool o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            fixed (bool* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetValueAsBool((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Gets a value as an 8-bit unsigned integer.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a uint8 that will be filled with the value.</param>
        /// <returns>true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Byte. The type can be tested with a call to ValueID::GetType</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsByte(global::OpenZWave.ValueID _id, byte* o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetValueAsByte((__Instance + __PointerAdjustment), __arg0, o_value);
            return __ret;
        }

        /// <summary>Gets a value as a float.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a float that will be filled with the value.</param>
        /// <returns>true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsFloat(global::OpenZWave.ValueID _id, ref float o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            fixed (float* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetValueAsFloat((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Gets a value as a 32-bit signed integer.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to an int32 that will be filled with the value.</param>
        /// <returns>true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Int. The type can be tested with a call to ValueID::GetType</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsInt(global::OpenZWave.ValueID _id, ref int o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            fixed (int* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetValueAsInt((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Gets a value as a 16-bit signed integer.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to an int16 that will be filled with the value.</param>
        /// <returns>true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Short. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsString, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsShort(global::OpenZWave.ValueID _id, ref short o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            fixed (short* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetValueAsShort((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Gets a value as a string.</para>
        /// <para>Creates a string representation of a value, regardless of type.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a string that will be filled with the value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsString(global::OpenZWave.ValueID _id, string o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __arg1 = global::Std.BasicStringExtensions.BasicString(o_value, new global::Std.Allocator<sbyte>()).__Instance;
            var __ret = __Internal.GetValueAsString((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Gets a value as a collection of bytes.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a uint8* that will be filled with the value. This return value will need to be freed as it was dynamically allocated.</param>
        /// <param name="o_length">Pointer to a uint8 that will be fill with the data length.</param>
        /// <returns>true if the value was obtained. Returns false if the value is not a ValueID::ValueType_Raw. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueListSelection, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueAsRaw(global::OpenZWave.ValueID _id, byte** o_value, byte* o_length)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetValueAsRaw((__Instance + __PointerAdjustment), __arg0, o_value, o_length);
            return __ret;
        }

        /// <summary>Gets the selected item from a list (as a string).</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a string that will be filled with the selected item.</param>
        /// <returns>True if the value was obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueListSelection(global::OpenZWave.ValueID _id, string o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __arg1 = global::Std.BasicStringExtensions.BasicString(o_value, new global::Std.Allocator<sbyte>()).__Instance;
            var __ret = __Internal.GetValueListSelection((__Instance + __PointerAdjustment), __arg0, __arg1);
            return __ret;
        }

        /// <summary>Gets the selected item from a list (as an integer).</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to an integer that will be filled with the selected item.</param>
        /// <returns>True if the value was obtained.  Returns false if the value is not a ValueID::ValueType_List. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsFloat, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListItems, GetValueAsRaw</para>
        /// </remarks>
        public bool GetValueListSelection(global::OpenZWave.ValueID _id, ref int o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            fixed (int* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetValueListSelection((__Instance + __PointerAdjustment), __arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>Gets a float value's precision.</summary>
        /// <param name="_id">The unique identifier of the value.</param>
        /// <param name="o_value">Pointer to a uint8 that will be filled with the precision value.</param>
        /// <returns>true if the value was obtained.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>ValueID::GetType, GetValueAsBool, GetValueAsByte, GetValueAsInt, GetValueAsShort, GetValueAsString, GetValueListSelection, GetValueListItems</para>
        /// </remarks>
        public bool GetValueFloatPrecision(global::OpenZWave.ValueID _id, byte* o_value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetValueFloatPrecision((__Instance + __PointerAdjustment), __arg0, o_value);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the state of a bool.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the bool value.</param>
        /// <param name="_value">The new value of the bool.</param>
        /// <returns>true if the value was set.  Returns false if the value is not a ValueID::ValueType_Bool. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, bool _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetValue((__Instance + __PointerAdjustment), __arg0, _value);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the value of a byte.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the byte value.</param>
        /// <param name="_value">The new value of the byte.</param>
        /// <returns>true if the value was set.  Returns false if the value is not a ValueID::ValueType_Byte. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, byte _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetValue_1((__Instance + __PointerAdjustment), __arg0, _value);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the value of a decimal.</para>
        /// <para>It is usually better to handle decimal values using strings rather than floats, to avoid floating point accuracy issues.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the decimal value.</param>
        /// <param name="_value">The new value of the decimal.</param>
        /// <returns>true if the value was set.  Returns false if the value is not a ValueID::ValueType_Decimal. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, float _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetValue_2((__Instance + __PointerAdjustment), __arg0, _value);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the value of a 32-bit signed integer.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the integer value.</param>
        /// <param name="_value">The new value of the integer.</param>
        /// <returns>true if the value was set.  Returns false if the value is not a ValueID::ValueType_Int. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, int _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetValue_3((__Instance + __PointerAdjustment), __arg0, _value);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the value of a 16-bit signed integer.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the integer value.</param>
        /// <param name="_value">The new value of the integer.</param>
        /// <returns>true if the value was set.  Returns false if the value is not a ValueID::ValueType_Short. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, short _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetValue_4((__Instance + __PointerAdjustment), __arg0, _value);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the value of a collection of bytes.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the raw value.</param>
        /// <param name="_value">The new collection of bytes.</param>
        /// <returns>true if the value was set.  Returns false if the value is not a ValueID::ValueType_Raw. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, byte* _value, byte _length)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetValue((__Instance + __PointerAdjustment), __arg0, _value, _length);
            return __ret;
        }

        /// <summary>
        /// <para>Sets the value from a string, regardless of type.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the integer value.</param>
        /// <param name="_value">The new value of the string.</param>
        /// <returns>true if the value was set.  Returns false if the value could not be parsed into the correct type for the value.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValue(global::OpenZWave.ValueID _id, string _value)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.SetValue((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>
        /// <para>Sets the selected item in a list.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the value</para>
        /// <para>held by the node is updated directly.  This will be reverted by a future status message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the list value.</param>
        /// <param name="_selectedItem">A string matching the new selected item in the list.</param>
        /// <returns>
        /// <para>true if the value was set.  Returns false if the selection is not in the list, or if the value is not a ValueID::ValueType_List.</para>
        /// <para>The type can be tested with a call to ValueID::GetType</para>
        /// </returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool SetValueListSelection(global::OpenZWave.ValueID _id, string _selectedItem)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_selectedItem, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.SetValueListSelection((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>
        /// <para>Refreshes the specified value from the Z-Wave network.</para>
        /// <para>A call to this function causes the library to send a message to the network to retrieve the current value</para>
        /// <para>of the specified ValueID (just like a poll, except only one-time, not recurring).</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the value to be refreshed.</param>
        /// <returns>true if the driver and node were found; false otherwise</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool RefreshValue(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.RefreshValue((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Sets a flag indicating whether value changes noted upon a refresh should be verified.  If so, the</para>
        /// <para>library will immediately refresh the value a second time whenever a change is observed.  This helps to filter</para>
        /// <para>out spurious data reported occasionally by some devices.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the value whose changes should or should not be verified.</param>
        /// <param name="_verify">if true, verify changes; if false, don't verify changes.</param>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>Manager::GetChangeVerified</para>
        /// </remarks>
        public void SetChangeVerified(global::OpenZWave.ValueID _id, bool _verify)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            __Internal.SetChangeVerified((__Instance + __PointerAdjustment), __arg0, _verify);
        }

        /// <summary>
        /// <para>determine if value changes upon a refresh should be verified.  If so, the</para>
        /// <para>library will immediately refresh the value a second time whenever a change is observed.  This helps to filter</para>
        /// <para>out spurious data reported occasionally by some devices.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the value whose changes should or should not be verified.</param>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>Manager::SetChangeVerified</para>
        /// </remarks>
        public bool GetChangeVerified(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetChangeVerified((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Starts an activity in a device.</para>
        /// <para>Since buttons are write-only values that do not report a state, no notification callbacks are sent.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the integer value.</param>
        /// <returns>true if the activity was started.  Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool PressButton(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.PressButton((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Stops an activity in a device.</para>
        /// <para>Since buttons are write-only values that do not report a state, no notification callbacks are sent.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the integer value.</param>
        /// <returns>true if the activity was stopped.  Returns false if the value is not a ValueID::ValueType_Button. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public bool ReleaseButton(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.ReleaseButton((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>Get the number of switch points defined in a schedule.</summary>
        /// <param name="_id">The unique identifier of the schedule value.</param>
        /// <returns>the number of switch points defined in this schedule.  Returns zero if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// </remarks>
        public byte GetNumSwitchPoints(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetNumSwitchPoints((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set a switch point in the schedule.</para>
        /// <para>Inserts a new switch point into the schedule, unless a switch point already exists at the specified</para>
        /// <para>time in which case that switch point is updated with the new setback value instead.</para>
        /// <para>A maximum of nine switch points can be set in the schedule.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the schedule value.</param>
        /// <param name="_hours">
        /// <para>The hours part of the time when the switch point will trigger.  The time is set using</para>
        /// <para>the 24-hour clock, so this value must be between 0 and 23.</para>
        /// </param>
        /// <param name="_minutes">
        /// <para>The minutes part of the time when the switch point will trigger.  This value must be</para>
        /// <para>between 0 and 59.</para>
        /// </param>
        /// <param name="_setback">
        /// <para>The setback in tenths of a degree Celsius.  The setback value can range from -128 (-12.8C)</para>
        /// <para>to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and</para>
        /// <para>122 is used to set Energy Saving mode.</para>
        /// </param>
        /// <returns>true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>GetNumSwitchPoints, RemoveSwitchPoint, ClearSwitchPoints</para>
        /// </remarks>
        public bool SetSwitchPoint(global::OpenZWave.ValueID _id, byte _hours, byte _minutes, sbyte _setback)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.SetSwitchPoint((__Instance + __PointerAdjustment), __arg0, _hours, _minutes, _setback);
            return __ret;
        }

        /// <summary>
        /// <para>Remove a switch point from the schedule.</para>
        /// <para>Removes the switch point at the specified time from the schedule.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the schedule value.</param>
        /// <param name="_hours">
        /// <para>The hours part of the time when the switch point will trigger.  The time is set using</para>
        /// <para>the 24-hour clock, so this value must be between 0 and 23.</para>
        /// </param>
        /// <param name="_minutes">
        /// <para>The minutes part of the time when the switch point will trigger.  This value must be</para>
        /// <para>between 0 and 59.</para>
        /// </param>
        /// <returns>
        /// <para>true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule or if there</para>
        /// <para>is not switch point with the specified time values. The type can be tested with a call to ValueID::GetType.</para>
        /// </returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>GetNumSwitchPoints, SetSwitchPoint, ClearSwitchPoints</para>
        /// </remarks>
        public bool RemoveSwitchPoint(global::OpenZWave.ValueID _id, byte _hours, byte _minutes)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.RemoveSwitchPoint((__Instance + __PointerAdjustment), __arg0, _hours, _minutes);
            return __ret;
        }

        /// <summary>Clears all switch points from the schedule.</summary>
        /// <param name="_id">The unique identifier of the schedule value.</param>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>GetNumSwitchPoints, SetSwitchPoint, RemoveSwitchPoint</para>
        /// </remarks>
        public void ClearSwitchPoints(global::OpenZWave.ValueID _id)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            __Internal.ClearSwitchPoints((__Instance + __PointerAdjustment), __arg0);
        }

        /// <summary>
        /// <para>Gets switch point data from the schedule.</para>
        /// <para>Retrieves the time and setback values from a switch point in the schedule.</para>
        /// </summary>
        /// <param name="_id">The unique identifier of the schedule value.</param>
        /// <param name="_idx">
        /// <para>The index of the switch point, between zero and one less than the value</para>
        /// <para>returned by GetNumSwitchPoints.</para>
        /// </param>
        /// <param name="o_hours">a pointer to a uint8 that will be filled with the hours part of the switch point data.</param>
        /// <param name="o_minutes">a pointer to a uint8 that will be filled with the minutes part of the switch point data.</param>
        /// <param name="o_setback">
        /// <para>a pointer to an int8 that will be filled with the setback value.  This can range from -128</para>
        /// <para>(-12.8C)to 120 (12.0C).  There are two special setback values - 121 is used to set Frost Protection mode, and</para>
        /// <para>122 is used to set Energy Saving mode.</para>
        /// </param>
        /// <returns>true if successful.  Returns false if the value is not a ValueID::ValueType_Schedule. The type can be tested with a call to ValueID::GetType.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_VALUEID if the ValueID is invalid</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_CANNOT_CONVERT_VALUEID if the Actual Value is off a different type</para>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_INVALID_HOMEID if the Driver cannot be found</para>
        /// <para>GetNumSwitchPoints</para>
        /// </remarks>
        public bool GetSwitchPoint(global::OpenZWave.ValueID _id, byte _idx, byte* o_hours, byte* o_minutes, sbyte* o_setback)
        {
            if (ReferenceEquals(_id, null))
                throw new global::System.ArgumentNullException("_id", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _id.__Instance;
            var __ret = __Internal.GetSwitchPoint((__Instance + __PointerAdjustment), __arg0, _idx, o_hours, o_minutes, o_setback);
            return __ret;
        }

        /// <summary>
        /// <para>Switch all devices on.</para>
        /// <para>All devices that support the SwitchAll command class will be turned on.</para>
        /// </summary>
        public void SwitchAllOn(uint _homeId)
        {
            __Internal.SwitchAllOn((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>
        /// <para>Switch all devices off.</para>
        /// <para>All devices that support the SwitchAll command class will be turned off.</para>
        /// </summary>
        public void SwitchAllOff(uint _homeId)
        {
            __Internal.SwitchAllOff((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>
        /// <para>Set the value of a configurable parameter in a device.</para>
        /// <para>Some devices have various parameters that can be configured to control the device behavior.</para>
        /// <para>These are not reported by the device over the Z-Wave network, but can usually be found in</para>
        /// <para>the device's user manual.</para>
        /// <para>This method returns immediately, without waiting for confirmation from the device that the</para>
        /// <para>change has been made.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to configure.</param>
        /// <param name="_param">The index of the parameter.</param>
        /// <param name="_value">The value to which the parameter should be set.</param>
        /// <param name="_size">Is an optional number of bytes to be sent for the parameter _value. Defaults to 2.</param>
        /// <returns>true if the a message setting the value was sent to the device.</returns>
        /// <remarks>RequestConfigParam</remarks>
        public bool SetConfigParam(uint _homeId, byte _nodeId, byte _param, int _value, byte _size)
        {
            var __ret = __Internal.SetConfigParam((__Instance + __PointerAdjustment), _homeId, _nodeId, _param, _value, _size);
            return __ret;
        }

        /// <summary>
        /// <para>Request the value of a configurable parameter from a device.</para>
        /// <para>Some devices have various parameters that can be configured to control the device behavior.</para>
        /// <para>These are not reported by the device over the Z-Wave network, but can usually be found in</para>
        /// <para>the device's user manual.</para>
        /// <para>This method requests the value of a parameter from the device, and then returns immediately,</para>
        /// <para>without waiting for a response.  If the parameter index is valid for this device, and the</para>
        /// <para>device is awake, the value will eventually be reported via a ValueChanged notification callback.</para>
        /// <para>The ValueID reported in the callback will have an index set the same as _param and a command class</para>
        /// <para>set to the same value as returned by a call to Configuration::StaticGetCommandClassId.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to configure.</param>
        /// <param name="_param">The index of the parameter.</param>
        /// <remarks>SetConfigParam, ValueID, Notification</remarks>
        public void RequestConfigParam(uint _homeId, byte _nodeId, byte _param)
        {
            __Internal.RequestConfigParam((__Instance + __PointerAdjustment), _homeId, _nodeId, _param);
        }

        /// <summary>Request the values of all known configurable parameters from a device.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node to configure.</param>
        /// <remarks>SetConfigParam, ValueID, Notification</remarks>
        public void RequestAllConfigParams(uint _homeId, byte _nodeId)
        {
            __Internal.RequestAllConfigParams((__Instance + __PointerAdjustment), _homeId, _nodeId);
        }

        /// <summary>
        /// <para>Gets the number of association groups reported by this node</para>
        /// <para>In Z-Wave, groups are numbered starting from one.  For example, if a call to GetNumGroups returns 4, the _groupIdx</para>
        /// <para>value to use in calls to GetAssociations, AddAssociation and RemoveAssociation will be a number between 1 and 4.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose groups we are interested in.</param>
        /// <returns>The number of groups.</returns>
        /// <remarks>GetAssociations, GetMaxAssociations, AddAssociation, RemoveAssociation</remarks>
        public byte GetNumGroups(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.GetNumGroups((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Gets the associations for a group.</para>
        /// <para>Makes a copy of the list of associated nodes in the group, and returns it in an array of uint8's.</para>
        /// <para>The caller is responsible for freeing the array memory with a call to delete [].</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose associations we are interested in.</param>
        /// <param name="_groupIdx">One-based index of the group (because Z-Wave product manuals use one-based group numbering).</param>
        /// <param name="o_associations">If the number of associations returned is greater than zero, o_associations will be set to point to an array containing the IDs of the associated nodes.</param>
        /// <returns>The number of nodes in the associations array.  If zero, the array will point to NULL, and does not need to be deleted.</returns>
        /// <remarks>GetNumGroups, AddAssociation, RemoveAssociation, GetMaxAssociations</remarks>
        public uint GetAssociations(uint _homeId, byte _nodeId, byte _groupIdx, byte** o_associations)
        {
            var __ret = __Internal.GetAssociations((__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx, o_associations);
            return __ret;
        }

        /// <summary>
        /// <para>Gets the associations for a group.</para>
        /// <para>Makes a copy of the list of associated nodes in the group, and returns it in an array of InstanceAssociation's.</para>
        /// <para>The caller is responsible for freeing the array memory with a call to delete [].</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose associations we are interested in.</param>
        /// <param name="_groupIdx">One-based index of the group (because Z-Wave product manuals use one-based group numbering).</param>
        /// <param name="o_associations">If the number of associations returned is greater than zero, o_associations will be set to point to an array containing the IDs and instances of the associated nodes.</param>
        /// <returns>The number of items in the associations array.  If zero, the array will point to NULL, and does not need to be deleted.</returns>
        /// <remarks>GetNumGroups, AddAssociation, RemoveAssociation, GetMaxAssociations</remarks>
        public uint GetAssociations(uint _homeId, byte _nodeId, byte _groupIdx, global::OpenZWave.InstanceAssociation o_associations)
        {
            var __arg3 = ReferenceEquals(o_associations, null) ? global::System.IntPtr.Zero : o_associations.__Instance;
            var __ret = __Internal.GetAssociations_1((__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx, __arg3);
            return __ret;
        }

        /// <summary>Gets the maximum number of associations for a group.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose associations we are interested in.</param>
        /// <param name="_groupIdx">one-based index of the group (because Z-Wave product manuals use one-based group numbering).</param>
        /// <returns>The maximum number of nodes that can be associated into the group.</returns>
        /// <remarks>GetNumGroups, AddAssociation, RemoveAssociation, GetAssociations</remarks>
        public byte GetMaxAssociations(uint _homeId, byte _nodeId, byte _groupIdx)
        {
            var __ret = __Internal.GetMaxAssociations((__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a label for the particular group of a node.</para>
        /// <para>This label is populated by the device specific configuration files.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose associations are to be changed.</param>
        /// <param name="_groupIdx">One-based index of the group (because Z-Wave product manuals use one-based group numbering).</param>
        /// <remarks>GetNumGroups, GetAssociations, GetMaxAssociations, AddAssociation</remarks>
        public string GetGroupLabel(uint _homeId, byte _nodeId, byte _groupIdx)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetGroupLabel(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>
        /// <para>Adds a node to an association group.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the association data</para>
        /// <para>held in this class is updated directly.  This will be reverted by a future Association message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.  Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose associations are to be changed.</param>
        /// <param name="_groupIdx">One-based index of the group (because Z-Wave product manuals use one-based group numbering).</param>
        /// <param name="_targetNodeId">Identifier for the node that will be added to the association group.</param>
        /// <param name="_instance">Identifier for the instance that will be added to the association group.</param>
        /// <remarks>GetNumGroups, GetAssociations, GetMaxAssociations, RemoveAssociation</remarks>
        public void AddAssociation(uint _homeId, byte _nodeId, byte _groupIdx, byte _targetNodeId, byte _instance)
        {
            __Internal.AddAssociation((__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx, _targetNodeId, _instance);
        }

        /// <summary>
        /// <para>Removes a node from an association group.</para>
        /// <para>Due to the possibility of a device being asleep, the command is assumed to succeed, and the association data</para>
        /// <para>held in this class is updated directly.  This will be reverted by a future Association message from the device</para>
        /// <para>if the Z-Wave message actually failed to get through.   Notification callbacks will be sent in both cases.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller that manages the node.</param>
        /// <param name="_nodeId">The ID of the node whose associations are to be changed.</param>
        /// <param name="_groupIdx">One-based index of the group (because Z-Wave product manuals use one-based group numbering).</param>
        /// <param name="_targetNodeId">Identifier for the node that will be removed from the association group.</param>
        /// <param name="_instance">Identifier for the instance that will be removed to the association group.</param>
        /// <remarks>GetNumGroups, GetAssociations, GetMaxAssociations, AddAssociation</remarks>
        public void RemoveAssociation(uint _homeId, byte _nodeId, byte _groupIdx, byte _targetNodeId, byte _instance)
        {
            __Internal.RemoveAssociation((__Instance + __PointerAdjustment), _homeId, _nodeId, _groupIdx, _targetNodeId, _instance);
        }

        /// <summary>
        /// <para>Add a notification watcher.</para>
        /// <para>In OpenZWave, all feedback from the Z-Wave network is sent to the application via callbacks.</para>
        /// <para>This method allows the application to add a notification callback handler, known as a &quot;watcher&quot; to OpenZWave.</para>
        /// <para>An application needs only add a single watcher - all notifications will be reported to it.</para>
        /// </summary>
        /// <param name="_watcher">pointer to a function that will be called by the notification system.</param>
        /// <param name="_context">pointer to user defined data that will be passed to the watcher function with each notification.</param>
        /// <returns>true if the watcher was successfully added.</returns>
        /// <remarks>RemoveWatcher, Notification</remarks>
        public bool AddWatcher(global::OpenZWave.Manager.PfnOnNotificationT _watcher, global::System.IntPtr _context)
        {
            var __arg0 = _watcher == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_watcher);
            var __ret = __Internal.AddWatcher((__Instance + __PointerAdjustment), __arg0, _context);
            return __ret;
        }

        /// <summary>Remove a notification watcher.</summary>
        /// <param name="_watcher">pointer to a function that must match that passed to a previous call to AddWatcher</param>
        /// <param name="_context">pointer to user defined data that must match the one passed in that same previous call to AddWatcher.</param>
        /// <returns>true if the watcher was successfully removed.</returns>
        /// <remarks>AddWatcher, Notification</remarks>
        public bool RemoveWatcher(global::OpenZWave.Manager.PfnOnNotificationT _watcher, global::System.IntPtr _context)
        {
            var __arg0 = _watcher == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_watcher);
            var __ret = __Internal.RemoveWatcher((__Instance + __PointerAdjustment), __arg0, _context);
            return __ret;
        }

        /// <summary>
        /// <para>Hard Reset a PC Z-Wave Controller.</para>
        /// <para>Resets a controller and erases its network configuration settings.  The controller becomes a primary controller ready to add devices to a new network.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller to be reset.</param>
        /// <remarks>SoftReset</remarks>
        public void ResetController(uint _homeId)
        {
            __Internal.ResetController((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>
        /// <para>Soft Reset a PC Z-Wave Controller.</para>
        /// <para>Resets a controller without erasing its network configuration settings.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller to be reset.</param>
        /// <remarks>SoftReset</remarks>
        public void SoftReset(uint _homeId)
        {
            __Internal.SoftReset((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>
        /// <para>Start a controller command process.</para>
        /// <para>Most Controller Commands are implemented via Other Manager methods, you should</para>
        /// <para>only use this method if you need advanced control over a existing Controller Command</para>
        /// <para>or if a ControllerCommand is not implemented.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <param name="_command">The command to be sent to the controller.</param>
        /// <param name="_callback">
        /// <para>pointer to a function that will be called at various stages during the command process</para>
        /// <para>to notify the user of progress or to request actions on the user's part.  Defaults to NULL. Callbacks are also sent</para>
        /// <para>via Notification mechanism with type of Notification::Type_ControllerCommand</para>
        /// </param>
        /// <param name="_context">pointer to user defined data that will be passed into to the callback function.  Defaults to NULL.</param>
        /// <param name="_highPower">
        /// <para>used only with the AddDevice, AddController, RemoveDevice and RemoveController commands.</para>
        /// <para>Usually when adding or removing devices, the controller operates at low power so that the controller must</para>
        /// <para>be physically close to the device for security reasons.  If _highPower is true, the controller will</para>
        /// <para>operate at normal power levels instead.  Defaults to false.</para>
        /// </param>
        /// <param name="_nodeId">is the node ID used by the command if necessary.</param>
        /// <param name="_arg">is an optional argument, usually another node ID, that is used by the command.</param>
        /// <returns>true if the command was accepted and has queued to be executed.</returns>
        /// <remarks>
        /// <para>CancelControllerCommand, HasNodeFailed, RemoveFailedNode, Driver::ControllerCommand, Driver::pfnControllerCallback_t,</para>
        /// <para>Commands</para>
        /// <para>- Driver::ControllerCommand_AddDevice - Add a new device or controller to the Z-Wave network.</para>
        /// <para>- Driver::ControllerCommand_CreateNewPrimary - Create a new primary controller when old primary fails. Requires SUC.</para>
        /// <para>- Driver::ControllerCommand_ReceiveConfiguration - Receive network configuration information from primary controller. Requires secondary.</para>
        /// <para>- Driver::ControllerCommand_RemoveDevice - Remove a device or controller from the Z-Wave network.</para>
        /// <para>- Driver::ControllerCommand_RemoveFailedNode - Remove a node from the network. The node must not be responding</para>
        /// <para>and be on the controller's failed node list.</para>
        /// <para>- Driver::ControllerCommand_HasNodeFailed - Check whether a node is in the controller's failed nodes list.</para>
        /// <para>- Driver::ControllerCommand_ReplaceFailedNode - Replace a failed device with another. If the node is not in</para>
        /// <para>the controller's failed nodes list, or the node responds, this command will fail.</para>
        /// <para>- Driver:: ControllerCommand_TransferPrimaryRole - Add a new controller to the network and</para>
        /// <para>make it the primary.  The existing primary will become a secondary controller.</para>
        /// <para>- Driver::ControllerCommand_RequestNetworkUpdate - Update the controller with network information from the SUC/SIS.</para>
        /// <para>- Driver::ControllerCommand_RequestNodeNeighborUpdate - Get a node to rebuild its neighbour list.  This method also does RequestNodeNeighbors afterwards.</para>
        /// <para>- Driver::ControllerCommand_AssignReturnRoute - Assign a network return route to a device.</para>
        /// <para>- Driver::ControllerCommand_DeleteAllReturnRoutes - Delete all network return routes from a device.</para>
        /// <para>- Driver::ControllerCommand_SendNodeInformation - Send a node information frame.</para>
        /// <para>- Driver::ControllerCommand_ReplicationSend - Send information from primary to secondary</para>
        /// <para>- Driver::ControllerCommand_CreateButton - Create a handheld button id.</para>
        /// <para>- Driver::ControllerCommand_DeleteButton - Delete a handheld button id.</para>
        /// <para>Callbacks</para>
        /// <para>- Driver::ControllerState_Starting, the controller command has begun</para>
        /// <para>- Driver::ControllerState_Waiting, the controller is waiting for a user action.  A notice should be displayed</para>
        /// <para>to the user at this point, telling them what to do next.</para>
        /// <para>For the add, remove, replace and transfer primary role commands, the user needs to be told to press the</para>
        /// <para>inclusion button on the device that  is going to be added or removed.  For ControllerCommand_ReceiveConfiguration,</para>
        /// <para>they must set their other controller to send its data, and for ControllerCommand_CreateNewPrimary, set the other</para>
        /// <para>controller to learn new data.</para>
        /// <para>- Driver::ControllerState_InProgress - the controller is in the process of adding or removing the chosen node.  It is now too late to cancel the command.</para>
        /// <para>- Driver::ControllerState_Complete - the controller has finished adding or removing the node, and the command is complete.</para>
        /// <para>- Driver::ControllerState_Failed - will be sent if the command fails for any reason.</para>
        /// <para>This method has been depreciated in favour of the methods in the</para>
        /// <para>AddNode RemoveNode RemoveFailedNode HasNodeFailed RequestNodeNeighborUpdate AssignReturnRoute DeleteAllReturnRoutes SendNodeInformation CreateNewPrimary ReceiveConfiguration ReplaceFailedNode TransferPrimaryRole RequestNetworkUpdate ReplicationSend CreateButton DeleteButton</para>
        /// </remarks>
        public bool BeginControllerCommand(uint _homeId, global::OpenZWave.Driver.ControllerCommand _command, global::OpenZWave.Driver.PfnControllerCallbackT _callback, global::System.IntPtr _context, bool _highPower, byte _nodeId, byte _arg)
        {
            var __arg2 = _callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_callback);
            var __ret = __Internal.BeginControllerCommand((__Instance + __PointerAdjustment), _homeId, _command, __arg2, _context, _highPower, _nodeId, _arg);
            return __ret;
        }

        /// <summary>Cancels any in-progress command running on a controller.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller.</param>
        /// <returns>true if a command was running and was cancelled.</returns>
        /// <remarks>BeginControllerCommand</remarks>
        public bool CancelControllerCommand(uint _homeId)
        {
            var __ret = __Internal.CancelControllerCommand((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Test network node.</para>
        /// <para>Sends a series of messages to a network node for testing network reliability.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller to be reset.</param>
        /// <param name="_count">This is the number of test messages to send.</param>
        /// <remarks>TestNetwork</remarks>
        public void TestNetworkNode(uint _homeId, byte _nodeId, uint _count)
        {
            __Internal.TestNetworkNode((__Instance + __PointerAdjustment), _homeId, _nodeId, _count);
        }

        /// <summary>
        /// <para>Test network.</para>
        /// <para>Sends a series of messages to every node on the network for testing network reliability.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller to be reset.</param>
        /// <param name="_count">This is the number of test messages to send.</param>
        /// <remarks>TestNetwork</remarks>
        public void TestNetwork(uint _homeId, uint _count)
        {
            __Internal.TestNetwork((__Instance + __PointerAdjustment), _homeId, _count);
        }

        /// <summary>
        /// <para>Heal network node by requesting the node rediscover their neighbors.</para>
        /// <para>Sends a ControllerCommand_RequestNodeNeighborUpdate to the node.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave network to be healed.</param>
        /// <param name="_nodeId">The node to heal.</param>
        /// <param name="_doRR">Whether to perform return routes initialization.</param>
        public void HealNetworkNode(uint _homeId, byte _nodeId, bool _doRR)
        {
            __Internal.HealNetworkNode((__Instance + __PointerAdjustment), _homeId, _nodeId, _doRR);
        }

        /// <summary>
        /// <para>Heal network by requesting node's rediscover their neighbors.</para>
        /// <para>Sends a ControllerCommand_RequestNodeNeighborUpdate to every node.</para>
        /// <para>Can take a while on larger networks.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave network to be healed.</param>
        /// <param name="_doRR">Whether to perform return routes initialization.</param>
        public void HealNetwork(uint _homeId, bool _doRR)
        {
            __Internal.HealNetwork((__Instance + __PointerAdjustment), _homeId, _doRR);
        }

        /// <summary>
        /// <para>Start the Inclusion Process to add a Node to the Network.</para>
        /// <para>The Status of the Node Inclusion is communicated via Notifications. Specifically, you should</para>
        /// <para>monitor ControllerCommand Notifications.</para>
        /// </summary>
        /// <param name="_homeId">The Home ID of the Z-Wave network where the device should be added.</param>
        /// <param name="_doSecurity">Whether to initialize the Network Key on the device if it supports the Security CC</param>
        /// <returns>if the Command was sent successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the AddNode Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool AddNode(uint _homeId, bool _doSecurity)
        {
            var __ret = __Internal.AddNode((__Instance + __PointerAdjustment), _homeId, _doSecurity);
            return __ret;
        }

        /// <summary>
        /// <para>Remove a Device from the Z-Wave Network</para>
        /// <para>The Status of the Node Removal is communicated via Notifications. Specifically, you should</para>
        /// <para>monitor ControllerCommand Notifications.</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network where you want to remove the device</param>
        /// <returns>if the Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the RemoveNode Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool RemoveNode(uint _homeId)
        {
            var __ret = __Internal.RemoveNode((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Remove a Failed Device from the Z-Wave Network</para>
        /// <para>This Command will remove a failed node from the network. The Node should be on the Controllers Failed</para>
        /// <para>Node List, otherwise this command will fail. You can use the HasNodeFailed function below to test if the Controller</para>
        /// <para>believes the Node has Failed.</para>
        /// <para>The Status of the Node Removal is communicated via Notifications. Specifically, you should</para>
        /// <para>monitor ControllerCommand Notifications.</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network where you want to remove the device</param>
        /// <param name="_nodeId">The NodeID of the Failed Node.</param>
        /// <returns>if the Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the RemoveFailedNode Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool RemoveFailedNode(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.RemoveFailedNode((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Check if the Controller Believes a Node has Failed.</para>
        /// <para>This is different from the IsNodeFailed call in that we test the Controllers Failed Node List, whereas the IsNodeFailed is testing</para>
        /// <para>our list of Failed Nodes, which might be different.</para>
        /// <para>The Results will be communicated via Notifications. Specifically, you should monitor the ControllerCommand notifications</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network where you want to test the device</param>
        /// <param name="_nodeId">The NodeID of the Failed Node.</param>
        /// <returns>if the RemoveDevice Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the HasNodeFailed Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool HasNodeFailed(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.HasNodeFailed((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Ask a Node to update its Neighbor Tables</para>
        /// <para>This command will ask a Node to update its Neighbor Tables.</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network where you want to update the device</param>
        /// <param name="_nodeId">The NodeID of the Node.</param>
        /// <returns>if the Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the RequestNodeNeighborUpdate Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool RequestNodeNeighborUpdate(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.RequestNodeNeighborUpdate((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Ask a Node to update its update its Return Route to the Controller</para>
        /// <para>This command will ask a Node to update its Return Route to the Controller</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network where you want to update the device</param>
        /// <param name="_nodeId">The NodeID of the Node.</param>
        /// <returns>if the Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the AssignReturnRoute Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool AssignReturnRoute(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.AssignReturnRoute((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Ask a Node to delete all Return Route.</para>
        /// <para>This command will ask a Node to delete all its return routes, and will rediscover when needed.</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network where you want to update the device</param>
        /// <param name="_nodeId">The NodeID of the Node.</param>
        /// <returns>if the Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the DeleteAllReturnRoutes Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool DeleteAllReturnRoutes(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.DeleteAllReturnRoutes((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Send a NIF frame from the Controller to a Node.</para>
        /// <para>This command send a NIF frame from the Controller to a Node</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <param name="_nodeId">The NodeID of the Node to receive the NIF</param>
        /// <returns>if the sendNIF Command was send successfully to the Controller</returns>
        /// <remarks>CancelControllerCommand</remarks>
        public bool SendNodeInformation(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.SendNodeInformation((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Create a new primary controller when old primary fails. Requires SUC.</para>
        /// <para>This command Creates a new Primary Controller when the Old Primary has Failed. Requires a SUC on the network to function</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <returns>if the CreateNewPrimary Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the CreateNewPrimary Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool CreateNewPrimary(uint _homeId)
        {
            var __ret = __Internal.CreateNewPrimary((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Receive network configuration information from primary controller. Requires secondary.</para>
        /// <para>This command prepares the controller to receive Network Configuration from a Secondary Controller.</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <returns>if the ReceiveConfiguration Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the ReceiveConfiguration Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool ReceiveConfiguration(uint _homeId)
        {
            var __ret = __Internal.ReceiveConfiguration((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>
        /// <para>Replace a failed device with another.</para>
        /// <para>If the node is not in the controller's failed nodes list, or the node responds, this command will fail.</para>
        /// <para>You can check if a Node is in the Controllers Failed node list by using the HasNodeFailed method</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <param name="_nodeId">the ID of the Failed Node</param>
        /// <returns>if the ReplaceFailedNode Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the ReplaceFailedNode Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>HasNodeFailed</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool ReplaceFailedNode(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.ReplaceFailedNode((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>
        /// <para>Add a new controller to the network and make it the primary.</para>
        /// <para>The existing primary will become a secondary controller.</para>
        /// </summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <returns>if the TransferPrimaryRole Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the TransferPrimaryRole Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool TransferPrimaryRole(uint _homeId)
        {
            var __ret = __Internal.TransferPrimaryRole((__Instance + __PointerAdjustment), _homeId);
            return __ret;
        }

        /// <summary>Update the controller with network information from the SUC/SIS.</summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <param name="_nodeId">the ID of the Node</param>
        /// <returns>if the RequestNetworkUpdate Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the RequestNetworkUpdate Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool RequestNetworkUpdate(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.RequestNetworkUpdate((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Send information from primary to secondary</summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <param name="_nodeId">the ID of the Node</param>
        /// <returns>if the ReplicationSend Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Results of the ReplicationSend Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool ReplicationSend(uint _homeId, byte _nodeId)
        {
            var __ret = __Internal.ReplicationSend((__Instance + __PointerAdjustment), _homeId, _nodeId);
            return __ret;
        }

        /// <summary>Create a handheld button id.</summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <param name="_nodeId">the ID of the Virtual Node</param>
        /// <param name="_buttonId">the ID of the Button to create</param>
        /// <returns>if the CreateButton Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Only intended for Bridge Firmware Controllers.</para>
        /// <para>Results of the CreateButton Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool CreateButton(uint _homeId, byte _nodeId, byte _buttonid)
        {
            var __ret = __Internal.CreateButton((__Instance + __PointerAdjustment), _homeId, _nodeId, _buttonid);
            return __ret;
        }

        /// <summary>Delete a handheld button id.</summary>
        /// <param name="_homeId">The HomeID of the Z-Wave network</param>
        /// <param name="_nodeId">the ID of the Virtual Node</param>
        /// <param name="_buttonId">the ID of the Button to delete</param>
        /// <returns>if the DeleteButton Command was send successfully to the Controller</returns>
        /// <remarks>
        /// <para>Only intended for Bridge Firmware Controllers.</para>
        /// <para>Results of the DeleteButton Command will be send as a Notification with the Notification type as</para>
        /// <para>Notification::Type_ControllerCommand</para>
        /// <para>CancelControllerCommand</para>
        /// </remarks>
        public bool DeleteButton(uint _homeId, byte _nodeId, byte _buttonid)
        {
            var __ret = __Internal.DeleteButton((__Instance + __PointerAdjustment), _homeId, _nodeId, _buttonid);
            return __ret;
        }

        /// <summary>Gets a list of all the SceneIds.</summary>
        /// <param name="_sceneIds">is a pointer to an array of integers.</param>
        /// <returns>The number of scenes. If zero, _sceneIds will be NULL and doesn't need to be freed.</returns>
        /// <remarks>GetNumScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public byte GetAllScenes(byte** _sceneIds)
        {
            var __ret = __Internal.GetAllScenes((__Instance + __PointerAdjustment), _sceneIds);
            return __ret;
        }

        /// <summary>Remove all the SceneIds.</summary>
        /// <param name="_homeId">The Home ID of the Z-Wave controller. 0 for all devices from all scenes.</param>
        /// <remarks>GetAllScenes, GetNumScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public void RemoveAllScenes(uint _homeId)
        {
            __Internal.RemoveAllScenes((__Instance + __PointerAdjustment), _homeId);
        }

        /// <summary>Create a new Scene passing in Scene ID</summary>
        /// <returns>uint8 Scene ID used to reference the scene. 0 is failure result.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public byte CreateScene()
        {
            var __ret = __Internal.CreateScene((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>Remove an existing Scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID to be removed.</param>
        /// <returns>true if scene was removed.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool RemoveScene(byte _sceneId)
        {
            var __ret = __Internal.RemoveScene((__Instance + __PointerAdjustment), _sceneId);
            return __ret;
        }

        /// <summary>Add a bool Value ID to an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the bool value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, bool _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.AddSceneValue((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Add a byte Value ID to an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the byte value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, byte _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.AddSceneValue_1((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Add a decimal Value ID to an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the float value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, float _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.AddSceneValue_2((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Add a 32-bit signed integer Value ID to an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the int32 value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, int _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.AddSceneValue_3((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Add a 16-bit signed integer Value ID to an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the int16 value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, short _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.AddSceneValue_4((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Add a string Value ID to an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the string value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, string _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.AddSceneValue((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            return __ret;
        }

        /// <summary>Add the selected item list Value ID to an existing scene (as a string).</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the string value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValueListSelection(byte _sceneId, global::OpenZWave.ValueID _valueId, string _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.AddSceneValueListSelection((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            return __ret;
        }

        /// <summary>Add the selected item list Value ID to an existing scene (as a integer).</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the integer value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool AddSceneValueListSelection(byte _sceneId, global::OpenZWave.ValueID _valueId, int _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.AddSceneValueListSelection((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Remove the Value ID from an existing scene.</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be removed.</param>
        /// <returns>true if Value ID was removed.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool RemoveSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.RemoveSceneValue((__Instance + __PointerAdjustment), _sceneId, __arg1);
            return __ret;
        }

        /// <summary>Retrieves a scene's value as a bool.</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a bool that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueAsBool(byte _sceneId, global::OpenZWave.ValueID _valueId, ref bool o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            fixed (bool* __refParamPtr2 = &o_value)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.SceneGetValueAsBool((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>Retrieves a scene's value as an 8-bit unsigned integer.</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a uint8 that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueAsByte(byte _sceneId, global::OpenZWave.ValueID _valueId, byte* o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SceneGetValueAsByte((__Instance + __PointerAdjustment), _sceneId, __arg1, o_value);
            return __ret;
        }

        /// <summary>Retrieves a scene's value as a float.</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a float that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueAsFloat(byte _sceneId, global::OpenZWave.ValueID _valueId, ref float o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            fixed (float* __refParamPtr2 = &o_value)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.SceneGetValueAsFloat((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>Retrieves a scene's value as a 32-bit signed integer.</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a int32 that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueAsInt(byte _sceneId, global::OpenZWave.ValueID _valueId, ref int o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            fixed (int* __refParamPtr2 = &o_value)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.SceneGetValueAsInt((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>Retrieves a scene's value as a 16-bit signed integer.</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a int16 that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueAsShort(byte _sceneId, global::OpenZWave.ValueID _valueId, ref short o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            fixed (short* __refParamPtr2 = &o_value)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.SceneGetValueAsShort((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>Retrieves a scene's value as a string.</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a string that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueAsString(byte _sceneId, global::OpenZWave.ValueID _valueId, string o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __arg2 = global::Std.BasicStringExtensions.BasicString(o_value, new global::Std.Allocator<sbyte>()).__Instance;
            var __ret = __Internal.SceneGetValueAsString((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Retrieves a scene's value as a list (as a string).</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a string that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueListSelection(byte _sceneId, global::OpenZWave.ValueID _valueId, string o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __arg2 = global::Std.BasicStringExtensions.BasicString(o_value, new global::Std.Allocator<sbyte>()).__Instance;
            var __ret = __Internal.SceneGetValueListSelection((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
            return __ret;
        }

        /// <summary>Retrieves a scene's value as a list (as a integer).</summary>
        /// <param name="_sceneId">The Scene ID of the scene to retrieve the value from.</param>
        /// <param name="_valueId">The Value ID of the value to retrieve.</param>
        /// <param name="o_value">Pointer to a integer that will be filled with the returned value.</param>
        /// <returns>true if the value was obtained.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SceneGetValueListSelection(byte _sceneId, global::OpenZWave.ValueID _valueId, ref int o_value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            fixed (int* __refParamPtr2 = &o_value)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.SceneGetValueListSelection((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>Set a bool Value ID to an existing scene's ValueID</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the bool value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, bool _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SetSceneValue((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Set a byte Value ID to an existing scene's ValueID</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the byte value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, byte _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SetSceneValue_1((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Set a decimal Value ID to an existing scene's ValueID</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the float value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, float _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SetSceneValue_2((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Set a 32-bit signed integer Value ID to an existing scene's ValueID</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the int32 value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, int _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SetSceneValue_3((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Set a 16-bit integer Value ID to an existing scene's ValueID</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the int16 value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, short _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SetSceneValue_4((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Set a string Value ID to an existing scene's ValueID</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the string value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValue(byte _sceneId, global::OpenZWave.ValueID _valueId, string _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.SetSceneValue((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            return __ret;
        }

        /// <summary>Set the list selected item Value ID to an existing scene's ValueID (as a string).</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the string value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValueListSelection(byte _sceneId, global::OpenZWave.ValueID _valueId, string _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_value, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.SetSceneValueListSelection((__Instance + __PointerAdjustment), _sceneId, __arg1, __arg2);
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            return __ret;
        }

        /// <summary>Set the list selected item Value ID to an existing scene's ValueID (as a integer).</summary>
        /// <param name="_sceneId">is an integer representing the unique Scene ID.</param>
        /// <param name="_valueId">is the Value ID to be added.</param>
        /// <param name="_value">is the integer value to be saved.</param>
        /// <returns>true if Value ID was added.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public bool SetSceneValueListSelection(byte _sceneId, global::OpenZWave.ValueID _valueId, int _value)
        {
            if (ReferenceEquals(_valueId, null))
                throw new global::System.ArgumentNullException("_valueId", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = _valueId.__Instance;
            var __ret = __Internal.SetSceneValueListSelection((__Instance + __PointerAdjustment), _sceneId, __arg1, _value);
            return __ret;
        }

        /// <summary>Returns a label for the particular scene.</summary>
        /// <param name="_sceneId">The Scene ID</param>
        /// <returns>The label string.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public string GetSceneLabel(byte _sceneId)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.GetSceneLabel(new IntPtr(&__ret), (__Instance + __PointerAdjustment), _sceneId);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Sets a label for the particular scene.</summary>
        /// <param name="_sceneId">The Scene ID</param>
        /// <param name="_value">The new value of the label.</param>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SceneExists, ActivateScene</remarks>
        public void SetSceneLabel(byte _sceneId, string _value)
        {
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_value, __allocator1);
            var __arg1 = __basicString1.__Instance;
            __Internal.SetSceneLabel((__Instance + __PointerAdjustment), _sceneId, __arg1);
            __basicString1.Dispose(false);
            __allocator1.Dispose();
        }

        /// <summary>Check if a Scene ID is defined.</summary>
        /// <param name="_sceneId">The Scene ID.</param>
        /// <returns>true if Scene ID exists.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, ActivateScene</remarks>
        public bool SceneExists(byte _sceneId)
        {
            var __ret = __Internal.SceneExists((__Instance + __PointerAdjustment), _sceneId);
            return __ret;
        }

        /// <summary>Activate given scene to perform all its actions.</summary>
        /// <param name="_sceneId">The Scene ID.</param>
        /// <returns>true if it is successful.</returns>
        /// <remarks>GetNumScenes, GetAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists</remarks>
        public bool ActivateScene(byte _sceneId)
        {
            var __ret = __Internal.ActivateScene((__Instance + __PointerAdjustment), _sceneId);
            return __ret;
        }

        /// <summary>Retrieve statistics from driver</summary>
        /// <param name="_homeId">The Home ID of the driver to obtain counters</param>
        /// <param name="_data">Pointer to structure DriverData to return values</param>
        public void GetDriverStatistics(uint _homeId, global::OpenZWave.Driver.DriverData _data)
        {
            var __arg1 = ReferenceEquals(_data, null) ? global::System.IntPtr.Zero : _data.__Instance;
            __Internal.GetDriverStatistics((__Instance + __PointerAdjustment), _homeId, __arg1);
        }

        /// <summary>Retrieve statistics per node</summary>
        /// <param name="_homeId">The Home ID of the driver for the node</param>
        /// <param name="_nodeId">The node number</param>
        /// <param name="_data">Pointer to structure NodeData to return values</param>
        public void GetNodeStatistics(uint _homeId, byte _nodeId, global::OpenZWave.Node.NodeData _data)
        {
            var __arg2 = ReferenceEquals(_data, null) ? global::System.IntPtr.Zero : _data.__Instance;
            __Internal.GetNodeStatistics((__Instance + __PointerAdjustment), _homeId, _nodeId, __arg2);
        }

        /// <summary>
        /// <para>Creates the Manager singleton object.</para>
        /// <para>The Manager provides the public interface to OpenZWave, exposing all the functionality required</para>
        /// <para>to add Z-Wave support to an application. There can be only one Manager in an OpenZWave application.</para>
        /// <para>An Options object must be created and Locked first, otherwise the call to Manager::Create will</para>
        /// <para>fail. Once the Manager has been created, call AddWatcher to install a notification callback handler,</para>
        /// <para>and then call the AddDriver method for each attached PC Z-Wave controller in turn.</para>
        /// </summary>
        /// <param name="_options">a locked Options object containing all the application's configurable option values.</param>
        /// <returns>a pointer to the newly created Manager object, or NULL if creation failed.</returns>
        /// <remarks>
        /// <para>OZWException with Type OZWException::OZWEXCEPTION_OPTIONS if the Options Class is not setup and Locked</para>
        /// <para>Options, Get, Destroy, AddWatcher, AddDriver</para>
        /// </remarks>
        public static global::OpenZWave.Manager Create()
        {
            var __ret = __Internal.Create();
            global::OpenZWave.Manager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::OpenZWave.Manager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::OpenZWave.Manager) global::OpenZWave.Manager.NativeToManagedMap[__ret];
            else global::OpenZWave.Manager.NativeToManagedMap[__ret] = __result0 = (global::OpenZWave.Manager) global::OpenZWave.Manager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Gets a pointer to the Manager object.</summary>
        /// <returns>pointer to the Manager object, or NULL if Create has not yet been called.</returns>
        /// <remarks>Create, Destroy</remarks>
        public static global::OpenZWave.Manager Get()
        {
            var __ret = __Internal.Get();
            global::OpenZWave.Manager __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::OpenZWave.Manager.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::OpenZWave.Manager) global::OpenZWave.Manager.NativeToManagedMap[__ret];
            else global::OpenZWave.Manager.NativeToManagedMap[__ret] = __result0 = (global::OpenZWave.Manager) global::OpenZWave.Manager.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Deletes the Manager and cleans up any associated objects.</summary>
        /// <remarks>Create, Get</remarks>
        public static void Destroy()
        {
            __Internal.Destroy();
        }

        /// <summary>Get the time period between polls of a node's state.</summary>
        public int PollInterval
        {
            get
            {
                var __ret = __Internal.GetPollInterval((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the Version Number of OZW as a string</summary>
        /// <returns>a String representing the version number as MAJOR.MINOR.REVISION</returns>
        public static string VersionAsString
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetVersionAsString(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        /// <summary>Get the Version Number including Git commit of OZW as a string</summary>
        /// <returns>a String representing the version number as MAJOR.MINOR.REVISION-gCOMMIT</returns>
        public static string VersionLongAsString
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetVersionLongAsString(new IntPtr(&__ret));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }

        /// <summary>Gets a pointer to the locked Options object.</summary>
        /// <returns>pointer to the Options object.</returns>
        /// <remarks>Create</remarks>
        public global::OpenZWave.Options Options
        {
            get
            {
                var __ret = __Internal.GetOptions((__Instance + __PointerAdjustment));
                global::OpenZWave.Options __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::OpenZWave.Options.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::OpenZWave.Options) global::OpenZWave.Options.NativeToManagedMap[__ret];
                else __result0 = global::OpenZWave.Options.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Gets the number of scenes that have been defined.</summary>
        /// <returns>The number of scenes.</returns>
        /// <remarks>GetAllScenes, RemoveAllScenes, CreateScene, RemoveScene, AddSceneValue, RemoveSceneValue, SceneGetValues, SceneGetValueAsBool, SceneGetValueAsByte, SceneGetValueAsFloat, SceneGetValueAsInt, SceneGetValueAsShort, SceneGetValueAsString, SetSceneValue, GetSceneLabel, SetSceneLabel, SceneExists, ActivateScene</remarks>
        public byte NumScenes
        {
            get
            {
                var __ret = __Internal.GetNumScenes((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>
    /// <para>Provides a container for data sent via the notification callback</para>
    /// <para>handler installed by a call to Manager::AddWatcher.</para>
    /// </summary>
    /// <remarks>
    /// <para>A notification object is only ever created or deleted internally by</para>
    /// <para>OpenZWave.</para>
    /// </remarks>
    public unsafe partial class Notification : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::OpenZWave.Notification.NotificationType m_type;

            [FieldOffset(4)]
            internal global::OpenZWave.ValueID.__Internal m_valueId;

            [FieldOffset(16)]
            internal byte m_byte;

            [FieldOffset(17)]
            internal byte m_event;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12NotificationC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave12NotificationD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification7GetTypeEv")]
            internal static extern global::OpenZWave.Notification.NotificationType GetType(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification9GetHomeIdEv")]
            internal static extern uint GetHomeId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification9GetNodeIdEv")]
            internal static extern byte GetNodeId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification10GetValueIDEv")]
            internal static extern global::System.IntPtr GetValueID(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification11GetGroupIdxEv")]
            internal static extern byte GetGroupIdx(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification8GetEventEv")]
            internal static extern byte GetEvent(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification11GetButtonIdEv")]
            internal static extern byte GetButtonId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification10GetSceneIdEv")]
            internal static extern byte GetSceneId(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification15GetNotificationEv")]
            internal static extern byte GetCode(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification7GetByteEv")]
            internal static extern byte GetByte(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave12Notification11GetAsStringEv")]
            internal static extern void GetAsString(global::System.IntPtr @return, global::System.IntPtr instance);
        }

        /// <summary>
        /// <para>Notification types.</para>
        /// <para>Notifications of various Z-Wave events sent to the watchers</para>
        /// <para>registered with the Manager::AddWatcher method.</para>
        /// </summary>
        /// <remarks>
        /// <para>Manager::AddWatcher</para>
        /// <para>Manager::BeginControllerCommand</para>
        /// </remarks>
        public enum NotificationType : uint
        {
            /// <summary>A new node value has been added to OpenZWave's list. These notifications occur after a node has been discovered, and details of its command classes have been received.  Each command class may generate one or more values depending on the complexity of the item being represented.</summary>
            TypeValueAdded = 0,
            /// <summary>A node value has been removed from OpenZWave's list.  This only occurs when a node is removed.</summary>
            TypeValueRemoved = 1,
            /// <summary>A node value has been updated from the Z-Wave network and it is different from the previous value.</summary>
            TypeValueChanged = 2,
            /// <summary>A node value has been updated from the Z-Wave network.</summary>
            TypeValueRefreshed = 3,
            /// <summary>The associations for the node have changed. The application should rebuild any group information it holds about the node.</summary>
            TypeGroup = 4,
            /// <summary>A new node has been found (not already stored in zwcfg*.xml file)</summary>
            TypeNodeNew = 5,
            /// <summary>A new node has been added to OpenZWave's list.  This may be due to a device being added to the Z-Wave network, or because the application is initializing itself.</summary>
            TypeNodeAdded = 6,
            /// <summary>A node has been removed from OpenZWave's list.  This may be due to a device being removed from the Z-Wave network, or because the application is closing.</summary>
            TypeNodeRemoved = 7,
            /// <summary>Basic node information has been received, such as whether the node is a listening device, a routing device and its baud rate and basic, generic and specific types. It is after this notification that you can call Manager::GetNodeType to obtain a label containing the device description.</summary>
            TypeNodeProtocolInfo = 8,
            /// <summary>One of the node names has changed (name, manufacturer, product).</summary>
            TypeNodeNaming = 9,
            /// <summary>A node has triggered an event.  This is commonly caused when a node sends a Basic_Set command to the controller.  The event value is stored in the notification.</summary>
            TypeNodeEvent = 10,
            /// <summary>Polling of a node has been successfully turned off by a call to Manager::DisablePoll</summary>
            TypePollingDisabled = 11,
            /// <summary>Polling of a node has been successfully turned on by a call to Manager::EnablePoll</summary>
            TypePollingEnabled = 12,
            /// <summary>Scene Activation Set received</summary>
            TypeSceneEvent = 13,
            /// <summary>Handheld controller button event created</summary>
            TypeCreateButton = 14,
            /// <summary>Handheld controller button event deleted</summary>
            TypeDeleteButton = 15,
            /// <summary>Handheld controller button on pressed event</summary>
            TypeButtonOn = 16,
            /// <summary>Handheld controller button off pressed event</summary>
            TypeButtonOff = 17,
            /// <summary>A driver for a PC Z-Wave controller has been added and is ready to use.  The notification will contain the controller's Home ID, which is needed to call most of the Manager methods.</summary>
            TypeDriverReady = 18,
            /// <summary>Driver failed to load</summary>
            TypeDriverFailed = 19,
            /// <summary>All nodes and values for this driver have been removed.  This is sent instead of potentially hundreds of individual node and value notifications.</summary>
            TypeDriverReset = 20,
            /// <summary>The queries on a node that are essential to its operation have been completed. The node can now handle incoming messages.</summary>
            TypeEssentialNodeQueriesComplete = 21,
            /// <summary>All the initialization queries on a node have been completed.</summary>
            TypeNodeQueriesComplete = 22,
            /// <summary>All awake nodes have been queried, so client application can expected complete data for these nodes.</summary>
            TypeAwakeNodesQueried = 23,
            /// <summary>All nodes have been queried but some dead nodes found.</summary>
            TypeAllNodesQueriedSomeDead = 24,
            /// <summary>All nodes have been queried, so client application can expected complete data.</summary>
            TypeAllNodesQueried = 25,
            /// <summary>An error has occurred that we need to report.</summary>
            TypeNotification = 26,
            /// <summary>The Driver is being removed. (either due to Error or by request) Do Not Call Any Driver Related Methods after receiving this call</summary>
            TypeDriverRemoved = 27,
            /// <summary>
            /// <para>When Controller Commands are executed, Notifications of Success/Failure etc are communicated via this Notification</para>
            /// <para>Notification::GetEvent returns Driver::ControllerState and Notification::GetNotification returns Driver::ControllerError if there was a error</para>
            /// </summary>
            TypeControllerCommand = 28,
            /// <summary>The Device has been reset and thus removed from the NodeList in OZW</summary>
            TypeNodeReset = 29
        }

        /// <summary>
        /// <para>Notification codes.</para>
        /// <para>Notifications of the type Type_Notification convey some</para>
        /// <para>extra information defined here.</para>
        /// </summary>
        public enum NotificationCode : uint
        {
            /// <summary>Completed messages</summary>
            CodeMsgComplete = 0,
            /// <summary>Messages that timeout will send a Notification with this code.</summary>
            CodeTimeout = 1,
            /// <summary>Report on NoOperation message sent completion</summary>
            CodeNoOperation = 2,
            /// <summary>Report when a sleeping node wakes up</summary>
            CodeAwake = 3,
            /// <summary>Report when a node goes to sleep</summary>
            CodeSleep = 4,
            /// <summary>Report when a node is presumed dead</summary>
            CodeDead = 5,
            /// <summary>Report when a node is revived</summary>
            CodeAlive = 6
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Notification> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Notification>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Notification __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Notification(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Notification __CreateInstance(global::OpenZWave.Notification.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Notification(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Notification.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Notification.__Internal));
            *(global::OpenZWave.Notification.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Notification(global::OpenZWave.Notification.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Notification(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Notification(global::OpenZWave.Notification _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Notification.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::OpenZWave.Notification.__Internal*) __Instance) = *((global::OpenZWave.Notification.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Notification __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Get the type of this notification.</summary>
        /// <returns>the notification type.</returns>
        /// <remarks>NotificationType</remarks>
        public global::OpenZWave.Notification.NotificationType Type
        {
            get
            {
                var __ret = __Internal.GetType((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the Home ID of the driver sending this notification.</summary>
        /// <returns>the driver Home ID</returns>
        public uint HomeId
        {
            get
            {
                var __ret = __Internal.GetHomeId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the ID of any node involved in this notification.</summary>
        /// <returns>the node's ID</returns>
        public byte NodeId
        {
            get
            {
                var __ret = __Internal.GetNodeId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the unique ValueID of any value involved in this notification.</summary>
        /// <returns>the value's ValueID</returns>
        public global::OpenZWave.ValueID ValueID
        {
            get
            {
                var __ret = __Internal.GetValueID((__Instance + __PointerAdjustment));
                global::OpenZWave.ValueID __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::OpenZWave.ValueID.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::OpenZWave.ValueID) global::OpenZWave.ValueID.NativeToManagedMap[__ret];
                else __result0 = global::OpenZWave.ValueID.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>Get the index of the association group that has been changed.  Only valid in Notification::Type_Group notifications.</summary>
        /// <returns>the group index.</returns>
        public byte GroupIdx
        {
            get
            {
                var __ret = __Internal.GetGroupIdx((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the event value of a notification.  Only valid in Notification::Type_NodeEvent and Notification::Type_ControllerCommand notifications.</summary>
        /// <returns>the event value.</returns>
        public byte Event
        {
            get
            {
                var __ret = __Internal.GetEvent((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>
        /// <para>Get the button id of a notification.  Only valid in Notification::Type_CreateButton, Notification::Type_DeleteButton,</para>
        /// <para>Notification::Type_ButtonOn and Notification::Type_ButtonOff notifications.</para>
        /// </summary>
        /// <returns>the button id.</returns>
        public byte ButtonId
        {
            get
            {
                var __ret = __Internal.GetButtonId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the scene Id of a notification.  Only valid in Notification::Type_SceneEvent notifications.</summary>
        /// <returns>the event value.</returns>
        public byte SceneId
        {
            get
            {
                var __ret = __Internal.GetSceneId((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Get the notification code from a notification. Only valid for Notification::Type_Notification or Notification::Type_ControllerCommand notifications.</summary>
        /// <returns>the notification code.</returns>
        public byte Code
        {
            get
            {
                var __ret = __Internal.GetCode((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Helper function to simplify wrapping the notification class.  Should not normally need to be called.</summary>
        /// <returns>the internal byte value of the notification.</returns>
        public byte Byte
        {
            get
            {
                var __ret = __Internal.GetByte((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        /// <summary>Helper Function to return the Notification as a String</summary>
        /// <returns>A string representation of this Notification</returns>
        public string AsString
        {
            get
            {
                var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
                __Internal.GetAsString(new IntPtr(&__ret), (__Instance + __PointerAdjustment));
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
                __basicStringRet0.Dispose(false);
                return __stringRet0;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>Manages library options read from XML files or the command line.</summary>
    /// <remarks>
    /// <para>A class that manages program options read from XML files or the command line.</para>
    /// <para>The OpenZWave Manager class requires a complete and locked Options</para>
    /// <para>object when created.  The Options are therefore one of the first things that</para>
    /// <para>any OpenZWave application must deal with.</para>
    /// <para>Options are first read from an XML file called options.xml located in the</para>
    /// <para>User data folder (the path to which is supplied to the Options::Create method).</para>
    /// <para>This is the same folder that will be used by the Manager to save the state of</para>
    /// <para>each controller in the Z-Wave network, to avoid querying them for their entire</para>
    /// <para>state every time the application starts up.</para>
    /// <para>The second source of program options is a string, which will normally be the</para>
    /// <para>command line used to launch the application.</para>
    /// <para>In this way, common options can be specified in the XML, but over-ridden if</para>
    /// <para>necessary by the command line.</para>
    /// <para>The Options process is as follows:</para>
    /// <para>1) Create an Options object, providing paths to the OpenZWave config folder,</para>
    /// <para>the User data folder and any command line string containing program options.</para>
    /// <para>2) Call Options::AddOptionBool, Options::AddOptionInt or Options::AddOptionString</para>
    /// <para>to add any application-specific configurable options.  In this way, the Options</para>
    /// <para>class can be used for non-OpenZWave options as well.  (OpenZWave options must</para>
    /// <para>be specified in step #1 above (either via xml file or a command line string).</para>
    /// <para>3) Call Options::Lock.  This will cause the option values to be read from</para>
    /// <para>the options.xml file and the command line string, and will lock the options</para>
    /// <para>so that no more calls aside from GetOptionAs may be made.</para>
    /// <para>4) Create the OpenZWave Manager object.</para>
    /// </remarks>
    public unsafe partial class Options : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.Map.__Internalc__N_std_N___1_S_map____N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C____N_OpenZWave_S_Options_S_Option___N_std_N___1_S_less__S0____N_std_N___1_S_allocator____N_std_N___1_S_pair__1S0__S3_ m_options;

            [FieldOffset(24)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_xml;

            [FieldOffset(48)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_commandLine;

            [FieldOffset(72)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_SystemPath;

            [FieldOffset(96)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_LocalPath;

            [FieldOffset(120)]
            internal byte m_locked;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7OptionsC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7OptionsD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options6CreateERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_S9_")]
            internal static extern global::System.IntPtr Create(global::System.IntPtr _configPath, global::System.IntPtr _userPath, global::System.IntPtr _commandLine);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options7DestroyEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Destroy();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options3GetEv")]
            internal static extern global::System.IntPtr Get();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options4LockEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Lock(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options13AddOptionBoolERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddOptionBool(global::System.IntPtr instance, global::System.IntPtr _name, bool _default);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options12AddOptionIntERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddOptionInt(global::System.IntPtr instance, global::System.IntPtr _name, int _default);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options15AddOptionStringERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES9_b")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AddOptionString(global::System.IntPtr instance, global::System.IntPtr _name, global::System.IntPtr _default, bool _append);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options15GetOptionAsBoolERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPb")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetOptionAsBool(global::System.IntPtr instance, global::System.IntPtr _name, bool* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options14GetOptionAsIntERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPi")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetOptionAsInt(global::System.IntPtr instance, global::System.IntPtr _name, int* o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options17GetOptionAsStringERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEPS7_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetOptionAsString(global::System.IntPtr instance, global::System.IntPtr _name, global::System.IntPtr o_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7Options13GetOptionTypeERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern global::OpenZWave.Options.OptionType GetOptionType(global::System.IntPtr instance, global::System.IntPtr _name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZNK9OpenZWave7Options9AreLockedEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool AreLocked(global::System.IntPtr instance);
        }

        public enum OptionType : uint
        {
            OptionTypeInvalid = 0,
            OptionTypeBool = 1,
            OptionTypeInt = 2,
            OptionTypeString = 3
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Options> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Options>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Options __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Options(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Options __CreateInstance(global::OpenZWave.Options.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Options(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Options.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Options.__Internal));
            global::OpenZWave.Options.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Options(global::OpenZWave.Options.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Options(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Options(global::OpenZWave.Options _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Options.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Options __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Locks the options.</para>
        /// <para>Reads in option values from  the XML options file and command line string and</para>
        /// <para>marks the options as locked.  Once locked, no more calls to AddOption</para>
        /// <para>can be made.</para>
        /// <para>The options must be locked before the Manager::Create method is called.</para>
        /// </summary>
        /// <remarks>AddOption</remarks>
        public bool Lock()
        {
            var __ret = __Internal.Lock((__Instance + __PointerAdjustment));
            return __ret;
        }

        /// <summary>
        /// <para>Add a boolean option to the program.</para>
        /// <para>Adds an option to the program whose value can then be read from a file or command line.</para>
        /// <para>All calls to AddOptionInt must be made before Lock.</para>
        /// </summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive and must be unique.</param>
        /// <param name="_default">the default value for this option.</param>
        /// <remarks>GetOptionAsBool</remarks>
        public bool AddOptionBool(string _name, bool _default)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.AddOptionBool((__Instance + __PointerAdjustment), __arg0, _default);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>
        /// <para>Add an integer option to the program.</para>
        /// <para>Adds an option to the program whose value can then be read from a file or command line.</para>
        /// <para>All calls to AddOptionInt must be made before Lock.</para>
        /// </summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive and must be unique.</param>
        /// <param name="_default">the default value for this option.</param>
        /// <remarks>GetOptionAsInt</remarks>
        public bool AddOptionInt(string _name, int _default)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.AddOptionInt((__Instance + __PointerAdjustment), __arg0, _default);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>
        /// <para>Add a string option to the program.</para>
        /// <para>Adds an option to the program whose value can then be read from a file or command line.</para>
        /// <para>All calls to AddOptionString must be made before Lock.</para>
        /// </summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive and must be unique.</param>
        /// <param name="_default">the default value for this option.</param>
        /// <param name="_append">
        /// <para>Setting append to true will cause values read from the command line</para>
        /// <para>or XML file to be concatenated into a comma delimited list.  If _append is false,</para>
        /// <para>newer values will overwrite older ones.</para>
        /// </param>
        /// <remarks>GetOptionAsString</remarks>
        public bool AddOptionString(string _name, string _default, bool _append)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_default, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __ret = __Internal.AddOptionString((__Instance + __PointerAdjustment), __arg0, __arg1, _append);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            return __ret;
        }

        /// <summary>Get the value of a boolean option.</summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive.</param>
        /// <param name="o_value">a pointer to the item that will be filled with the option value.</param>
        /// <returns>
        /// <para>true if the option value was fetched successfully, false if the</para>
        /// <para>option does not exist, or does not contain a boolean value</para>
        /// </returns>
        /// <remarks>AddOptionBool, GetOptionType</remarks>
        public bool GetOptionAsBool(string _name, ref bool o_value)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            fixed (bool* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetOptionAsBool((__Instance + __PointerAdjustment), __arg0, __arg1);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
                return __ret;
            }
        }

        /// <summary>Get the value of an integer option.</summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive.</param>
        /// <param name="o_value">a pointer to the item that will be filled with the option value.</param>
        /// <returns>
        /// <para>true if the option value was fetched successfully, false if the</para>
        /// <para>option does not exist, or does not contain an integer value</para>
        /// </returns>
        /// <remarks>AddOptionInt, GetOptionType</remarks>
        public bool GetOptionAsInt(string _name, ref int o_value)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            fixed (int* __refParamPtr1 = &o_value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.GetOptionAsInt((__Instance + __PointerAdjustment), __arg0, __arg1);
                __basicString0.Dispose(false);
                __allocator0.Dispose();
                return __ret;
            }
        }

        /// <summary>Get the value of a string option.</summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive.</param>
        /// <param name="o_value">a pointer to the item that will be filled with the option value.</param>
        /// <returns>
        /// <para>true if the option value was fetched successfully, false if the</para>
        /// <para>option does not exist, or does not contain a string value</para>
        /// </returns>
        /// <remarks>AddOptionString, GetOptionType</remarks>
        public bool GetOptionAsString(string _name, string o_value)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __arg1 = global::Std.BasicStringExtensions.BasicString(o_value, new global::Std.Allocator<sbyte>()).__Instance;
            var __ret = __Internal.GetOptionAsString((__Instance + __PointerAdjustment), __arg0, __arg1);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Get the type of value stored in an option.</summary>
        /// <param name="_name">the name of the option.  Option names are case insensitive.</param>
        /// <returns>
        /// <para>An enum value representing the type of the option value.  If the</para>
        /// <para>option does not exist, OptionType_Invalid is returned.</para>
        /// </returns>
        /// <remarks>GetOptionAsBool, GetOptionAsInt, GetOptionAsString</remarks>
        public global::OpenZWave.Options.OptionType GetOptionType(string _name)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_name, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.GetOptionType((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            return __ret;
        }

        /// <summary>Creates an object to manage the program options.</summary>
        /// <param name="_configPath">
        /// <para>a string containing the path to the OpenZWave library config</para>
        /// <para>folder, which contains XML descriptions of Z-Wave manufacturers and products.</para>
        /// </param>
        /// <param name="_userPath">
        /// <para>a string containing the path to the application's user data</para>
        /// <para>folder where the OpenZWave should store the Z-Wave network configuration and state.</para>
        /// <para>The _userPath is also the folder where OpenZWave will look for the file Options.xml</para>
        /// <para>which contains program option values.  The file should be in the form outlined below,</para>
        /// <para>with one or more Option elements containing a name and value attribute.  Multiple</para>
        /// <para>values with the same option name should be listed separately. Note that option names</para>
        /// <para>are case insensitive.</para>
        /// </param>
        /// <param name="_commandLine">
        /// <para>a string containing the program's command line options.</para>
        /// <para>Command line options are parsed after the options.xml file, and so take precedence.</para>
        /// <para>Options are identified by a leading -- (two minus signs). The following items</para>
        /// <para>in the string are treated as values for this option, until the next -- is</para>
        /// <para>reached. For boolean options only, it is possible to omit the value, in which case</para>
        /// <para>the value is assumed to be &quot;true&quot;.  Note that option names are case insensitive, and</para>
        /// <para>that option values should be separated by a space.</para>
        /// </param>
        /// <returns>Pointer to the newly created Options object.</returns>
        /// <remarks>Get, Destroy, AddOption, GetOptionAs, Lock</remarks>
        public static global::OpenZWave.Options Create(string _configPath, string _userPath, string _commandLine)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_configPath, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __allocator1 = new global::Std.Allocator<sbyte>();
            var __basicString1 = global::Std.BasicStringExtensions.BasicString(_userPath, __allocator1);
            var __arg1 = __basicString1.__Instance;
            var __allocator2 = new global::Std.Allocator<sbyte>();
            var __basicString2 = global::Std.BasicStringExtensions.BasicString(_commandLine, __allocator2);
            var __arg2 = __basicString2.__Instance;
            var __ret = __Internal.Create(__arg0, __arg1, __arg2);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            __basicString1.Dispose(false);
            __allocator1.Dispose();
            __basicString2.Dispose(false);
            __allocator2.Dispose();
            global::OpenZWave.Options __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::OpenZWave.Options.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::OpenZWave.Options) global::OpenZWave.Options.NativeToManagedMap[__ret];
            else __result0 = global::OpenZWave.Options.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Deletes the Options and cleans up any associated objects.</para>
        /// <para>The application is responsible for destroying the Options object,</para>
        /// <para>but this must not be done until after the Manager object has been</para>
        /// <para>destroyed.</para>
        /// </summary>
        /// <param name="_options">Pointer to the Options object to be destroyed.</param>
        /// <returns>
        /// <para>true if the Options object was destroyed.  If the manager</para>
        /// <para>object still exists, this call will return false.</para>
        /// </returns>
        /// <remarks>Create, Get</remarks>
        public static bool Destroy()
        {
            var __ret = __Internal.Destroy();
            return __ret;
        }

        /// <summary>Gets a pointer to the Options singleton object.</summary>
        /// <returns>a pointer to the Options singleton object.</returns>
        /// <remarks>Create, Destroy</remarks>
        public static global::OpenZWave.Options Get()
        {
            var __ret = __Internal.Get();
            global::OpenZWave.Options __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::OpenZWave.Options.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::OpenZWave.Options) global::OpenZWave.Options.NativeToManagedMap[__ret];
            else __result0 = global::OpenZWave.Options.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>Test whether the options have been locked.</summary>
        /// <returns>true if the options have been locked.</returns>
        /// <remarks>Lock</remarks>
        public bool AreLocked
        {
            get
            {
                var __ret = __Internal.AreLocked((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }
}

namespace OpenZWave
{
    /// <summary>Collection of ValueIDs to be treated as a unit.</summary>
    public unsafe partial class Scene : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte m_sceneId;

            [FieldOffset(8)]
            internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C m_label;

            [FieldOffset(32)]
            internal global::Std.Vector.__Internalc__N_std_N___1_S_vector_____N_OpenZWave_S_Scene_S_SceneStorage___N_std_N___1_S_allocator__S0_ m_values;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5SceneC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave5SceneD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Scene> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Scene>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Scene __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Scene(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Scene __CreateInstance(global::OpenZWave.Scene.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Scene(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Scene.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Scene.__Internal));
            global::OpenZWave.Scene.__Internal.cctor(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Scene(global::OpenZWave.Scene.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Scene(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Scene(global::OpenZWave.Scene _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Scene.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Scene __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }
}

namespace OpenZWave
{
    public unsafe partial class LockGuard : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr _ref;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9LockGuardD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9LockGuard6UnlockEv")]
            internal static extern void Unlock(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.LockGuard> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.LockGuard>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.LockGuard __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.LockGuard(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.LockGuard __CreateInstance(global::OpenZWave.LockGuard.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.LockGuard(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.LockGuard.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.LockGuard.__Internal));
            *(global::OpenZWave.LockGuard.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LockGuard(global::OpenZWave.LockGuard.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected LockGuard(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.LockGuard __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor((__Instance + __PointerAdjustment));
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Unlock()
        {
            __Internal.Unlock((__Instance + __PointerAdjustment));
        }
    }

    public unsafe partial class Utils
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7ToUpperERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE")]
            internal static extern void ToUpper(global::System.IntPtr @return, global::System.IntPtr _str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave7ToLowerERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE")]
            internal static extern void ToLower(global::System.IntPtr @return, global::System.IntPtr _str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave4trimERNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE")]
            internal static extern global::System.IntPtr Trim(global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave8PrintHexENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEPKhj")]
            internal static extern void PrintHex(global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C prefix, byte* data, uint length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave11PktToStringEPKhj")]
            internal static extern void PktToString(global::System.IntPtr @return, byte* data, uint length);
        }

        /// <summary>Convert a string to all upper-case.</summary>
        /// <param name="_str">the string to be converted.</param>
        /// <returns>the upper-case string.</returns>
        /// <remarks>ToLower, Trim</remarks>
        public static string ToUpper(string _str)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.ToUpper(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Convert a string to all lower-case.</summary>
        /// <param name="_str">the string to be converted.</param>
        /// <returns>the lower-case string.</returns>
        /// <remarks>ToUpper, Trim</remarks>
        public static string ToLower(string _str)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_str, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.ToLower(new IntPtr(&__ret), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        /// <summary>Trim Whitespace from the start and end of a string.</summary>
        /// <param name="s">the string to trim</param>
        /// <returns>the trimmed string</returns>
        public static string Trim(string s)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(s, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Trim(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }

        public static void PrintHex(string prefix, byte* data, uint length)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(prefix, __allocator0);
            var __arg0 = *(global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C*) __basicString0.__Instance;
            __Internal.PrintHex(__arg0, data, length);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        public static string PktToString(byte* data, uint length)
        {
            var __ret = new global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C();
            __Internal.PktToString(new IntPtr(&__ret), data, length);
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            return __stringRet0;
        }
    }
}

namespace OpenZWave
{
    public enum LogLevel : uint
    {
        /// <summary>Invalid Log Status</summary>
        LogLevelInvalid = 0,
        /// <summary>Disable all logging</summary>
        LogLevelNone = 1,
        /// <summary>These messages should always be shown</summary>
        LogLevelAlways = 2,
        /// <summary>A likely fatal issue in the library</summary>
        LogLevelFatal = 3,
        /// <summary>A serious issue with the library or the network</summary>
        LogLevelError = 4,
        /// <summary>A minor issue from which the library should be able to recover</summary>
        LogLevelWarning = 5,
        /// <summary>Something unexpected by the library about which the controlling application should be aware</summary>
        LogLevelAlert = 6,
        /// <summary>Everything is working fine...these messages provide streamlined feedback on each message</summary>
        LogLevelInfo = 7,
        /// <summary>Detailed information on the progress of each message</summary>
        LogLevelDetail = 8,
        /// <summary>
        /// <para>Very detailed information on progress that will create a huge log file quickly</para>
        /// <para>But this level (as others) can be queued and sent to the log only on an error or warning</para>
        /// </summary>
        LogLevelDebug = 9,
        /// <summary>Will include low-level byte transfers from controller to buffer to application and back</summary>
        LogLevelStreamDetail = 10,
        /// <summary>Used only within the log class (uses existing timestamp, etc.)</summary>
        LogLevelInternal = 11
    }

    public unsafe abstract partial class ILogImpl : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr vptr_i_LogImpl;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9i_LogImplC2Ev")]
            internal static extern void ctor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9i_LogImplC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave9i_LogImplD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.ILogImpl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.ILogImpl>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.ILogImpl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.ILogImplInternal(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.ILogImpl __CreateInstance(global::OpenZWave.ILogImpl.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.ILogImplInternal(native, skipVTables);
        }

        protected ILogImpl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected ILogImpl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ILogImpl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "OpenZWave.ILogImpl");
        }

        protected ILogImpl(global::OpenZWave.ILogImpl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ILogImpl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "OpenZWave.ILogImpl");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.ILogImpl __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::OpenZWave.ILogImpl.__Internal*) __Instance)->vptr_i_LogImpl = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 8);
                if (__slot != null)
                {
                    var ___dtorDelegate = (global::OpenZWave.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr));
                    ___dtorDelegate((__Instance + __PointerAdjustment));
                }
                else
                    __Internal.dtor((__Instance + __PointerAdjustment));
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public abstract void QueueDump();

        public abstract void QueueClear();

        public abstract void SetLoggingState(global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger);

        public abstract void SetLogFileName(string _filename);

        #region Virtual table interop

        // virtual ~i_LogImpl() { }
        private static global::OpenZWave.Delegates.Action_IntPtr _dtorDelegateInstance;

        private static void _dtorDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.ILogImpl) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void QueueDump() = 0
        private static global::OpenZWave.Delegates.Action_IntPtr _QueueDumpDelegateInstance;

        private static void _QueueDumpDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.ILogImpl) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.QueueDump();
        }

        // void QueueClear() = 0
        private static global::OpenZWave.Delegates.Action_IntPtr _QueueClearDelegateInstance;

        private static void _QueueClearDelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.ILogImpl) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.QueueClear();
        }

        // void SetLoggingState( LogLevel _saveLevel, LogLevel _queueLevel, LogLevel _dumpTrigger ) = 0
        private static global::OpenZWave.Delegates.Action_IntPtr_OpenZWave_LogLevel_OpenZWave_LogLevel_OpenZWave_LogLevel _SetLoggingStateDelegateInstance;

        private static void _SetLoggingStateDelegateHook(global::System.IntPtr instance, global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.ILogImpl) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.SetLoggingState(_saveLevel, _queueLevel, _dumpTrigger);
        }

        // void SetLogFileName( const string &_filename ) = 0
        private static global::OpenZWave.Delegates.Action_IntPtr_IntPtr _SetLogFileNameDelegateInstance;

        private static void _SetLogFileNameDelegateHook(global::System.IntPtr instance, global::System.IntPtr _filename)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::OpenZWave.ILogImpl) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(_filename);
            var __stringRet0 = global::Std.BasicStringExtensions.CStr(__basicStringRet0);
            __basicStringRet0.Dispose(false);
            __target.SetLogFileName(__stringRet0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtorDelegateInstance += _dtorDelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance).ToPointer();
                _QueueDumpDelegateInstance += _QueueDumpDelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_QueueDumpDelegateInstance).ToPointer();
                _QueueClearDelegateInstance += _QueueClearDelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_QueueClearDelegateInstance).ToPointer();
                _SetLoggingStateDelegateInstance += _SetLoggingStateDelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetLoggingStateDelegateInstance).ToPointer();
                _SetLogFileNameDelegateInstance += _SetLogFileNameDelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_SetLogFileNameDelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(9 * 8);
                    var vfptr0 = vtptr + 2 * 8;
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -16);
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 24);
                    *(void**) (vfptr0 + 32) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 32);
                    *(void**) (vfptr0 + 40) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 40);
                    *(void**) (vfptr0 + 48) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 48);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vtptr = Marshal.AllocHGlobal(9 * 8);
                    var vfptr0 = vtptr + 2 * 8;
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + -16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -16);
                    *(void**) (vfptr0 + -8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + -8);
                    *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                    *(void**) (vfptr0 + 8) = _Thunks[0];
                    *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                    *(void**) (vfptr0 + 24) = _Thunks[1];
                    *(void**) (vfptr0 + 32) = _Thunks[2];
                    *(void**) (vfptr0 + 40) = _Thunks[3];
                    *(void**) (vfptr0 + 48) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    /// <summary>Implements a platform-independent log...written to the console and, optionally, a file.</summary>
    public unsafe partial class Log : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr m_logMutex;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3LogC2ERKS0_")]
            internal static extern void cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3LogD2Ev")]
            internal static extern void dtor(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log6CreateERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEbbNS_8LogLevelESA_SA_")]
            internal static extern global::System.IntPtr Create(global::System.IntPtr _filename, bool _bAppend, bool _bConsoleOutput, global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log6CreateEPNS_9i_LogImplE")]
            internal static extern global::System.IntPtr Create(global::System.IntPtr LogClass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log7DestroyEv")]
            internal static extern void Destroy();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log15SetLoggingClassEPNS_9i_LogImplE")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetLoggingClass(global::System.IntPtr LogClass);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log15SetLoggingStateENS_8LogLevelES1_S1_")]
            internal static extern void SetLoggingState(global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log15GetLoggingStateEPNS_8LogLevelES2_S2_")]
            internal static extern void GetLoggingState(global::OpenZWave.LogLevel* _saveLevel, global::OpenZWave.LogLevel* _queueLevel, global::OpenZWave.LogLevel* _dumpTrigger);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log14SetLogFileNameERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE")]
            internal static extern void SetLogFileName(global::System.IntPtr _filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log5WriteENS_8LogLevelEPKcz")]
            internal static extern void Write(global::OpenZWave.LogLevel _level, [MarshalAs(UnmanagedType.LPStr)] string _format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log5WriteENS_8LogLevelEhPKcz")]
            internal static extern void Write(global::OpenZWave.LogLevel _level, byte _nodeId, [MarshalAs(UnmanagedType.LPStr)] string _format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log9QueueDumpEv")]
            internal static extern void QueueDump();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log10QueueClearEv")]
            internal static extern void QueueClear();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log15GetLoggingStateEv")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetLoggingState();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave3Log15SetLoggingStateEb")]
            internal static extern void SetLoggingState(bool _dologging);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Log> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::OpenZWave.Log>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::OpenZWave.Log __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::OpenZWave.Log(native.ToPointer(), skipVTables);
        }

        internal static global::OpenZWave.Log __CreateInstance(global::OpenZWave.Log.__Internal native, bool skipVTables = false)
        {
            return new global::OpenZWave.Log(native, skipVTables);
        }

        private static void* __CopyValue(global::OpenZWave.Log.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Log.__Internal));
            *(global::OpenZWave.Log.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Log(global::OpenZWave.Log.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Log(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Log(global::OpenZWave.Log _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::OpenZWave.Log.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::OpenZWave.Log.__Internal*) __Instance) = *((global::OpenZWave.Log.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::OpenZWave.Log __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Create a log.</para>
        /// <para>Creates the cross-platform logging singleton.</para>
        /// <para>Any previous log will be cleared.</para>
        /// </summary>
        /// <returns>a pointer to the logging object.</returns>
        /// <remarks>Destroy, Write</remarks>
        public static global::OpenZWave.Log Create(string _filename, bool _bAppend, bool _bConsoleOutput, global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.Create(__arg0, _bAppend, _bConsoleOutput, _saveLevel, _queueLevel, _dumpTrigger);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            global::OpenZWave.Log __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::OpenZWave.Log.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::OpenZWave.Log) global::OpenZWave.Log.NativeToManagedMap[__ret];
            else __result0 = global::OpenZWave.Log.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Create a log.</para>
        /// <para>Creates the cross-platform logging singleton.</para>
        /// <para>Any previous log will be cleared.</para>
        /// </summary>
        /// <param name="LogClass">a Logging Class that inherits the i_LogImpl Class to use to Log</param>
        /// <returns>a pointer to the logging object.</returns>
        /// <remarks>Destroy, Write</remarks>
        public static global::OpenZWave.Log Create(global::OpenZWave.ILogImpl LogClass)
        {
            var __arg0 = ReferenceEquals(LogClass, null) ? global::System.IntPtr.Zero : LogClass.__Instance;
            var __ret = __Internal.Create(__arg0);
            global::OpenZWave.Log __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::OpenZWave.Log.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::OpenZWave.Log) global::OpenZWave.Log.NativeToManagedMap[__ret];
            else __result0 = global::OpenZWave.Log.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Destroys the log.</para>
        /// <para>Destroys the logging singleton.  The log can no longer</para>
        /// <para>be written to without another call to Create.</para>
        /// </summary>
        /// <remarks>Create, Write</remarks>
        public static void Destroy()
        {
            __Internal.Destroy();
        }

        /// <summary>Set the Logging Implementation Class to replace the standard File/Console logging</summary>
        /// <param name="LogClass">A Logging Class that inherits the i_LogImpl Class used to Log to</param>
        /// <returns>Bool Value indicating success or failure</returns>
        public static bool SetLoggingClass(global::OpenZWave.ILogImpl LogClass)
        {
            var __arg0 = ReferenceEquals(LogClass, null) ? global::System.IntPtr.Zero : LogClass.__Instance;
            var __ret = __Internal.SetLoggingClass(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Enable or disable library logging.  To disable, set _saveLevel and _queueLevel</para>
        /// <para>to LogLevel_None.</para>
        /// </summary>
        /// <param name="_saveLevel">LogLevel of messages to write in real-time</param>
        /// <param name="_queueLevel">LogLevel of messages to queue to be dumped in case of an error</param>
        /// <param name="_dumpTrigger">LogLevel of message that triggers a queue dump (probably LogLevel_Error or LogLevel_Warning)</param>
        public static void SetLoggingState(global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger)
        {
            __Internal.SetLoggingState(_saveLevel, _queueLevel, _dumpTrigger);
        }

        /// <summary>Obtain the various logging levels.</summary>
        /// <param name="_saveLevel">LogLevel of messages to write in real-time</param>
        /// <param name="_queueLevel">LogLevel of messages to queue to be dumped in case of an error</param>
        /// <param name="_dumpTrigger">LogLevel of message that triggers a queue dump (probably LogLevel_Error or LogLevel_Warning)</param>
        public static void GetLoggingState(global::OpenZWave.LogLevel* _saveLevel, global::OpenZWave.LogLevel* _queueLevel, global::OpenZWave.LogLevel* _dumpTrigger)
        {
            __Internal.GetLoggingState(_saveLevel, _queueLevel, _dumpTrigger);
        }

        /// <summary>
        /// <para>Change the log file name.  This will start a new log file (or potentially start appending</para>
        /// <para>information to an existing one.  Developers might want to use this function, together with a timer</para>
        /// <para>in the controlling application, to create timestamped log file names.</para>
        /// </summary>
        /// <param name="_filename">Name of the new (or existing) file to use for log output.</param>
        public static void SetLogFileName(string _filename)
        {
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            __Internal.SetLogFileName(__arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }

        /// <summary>
        /// <para>Write an entry to the log.</para>
        /// <para>Writes a formatted string to the log.</para>
        /// </summary>
        /// <param name="_level">Specifies the type of log message (Error, Warning, Debug, etc.)</param>
        /// <param name="_format.">A string formatted in the same manner as used with printf etc.</param>
        /// <param name="...">a variable number of arguments, to be included in the formatted string.</param>
        /// <remarks>Create, Destroy</remarks>
        public static void Write(global::OpenZWave.LogLevel _level, string _format)
        {
            __Internal.Write(_level, _format);
        }

        /// <summary>
        /// <para>Write an entry to the log.</para>
        /// <para>Writes a formatted string to the log.</para>
        /// </summary>
        /// <param name="_level">Specifies the type of log message (Error, Warning, Debug, etc.)</param>
        /// <param name="_nodeId">Node Id this entry is about.</param>
        /// <param name="_format.">A string formatted in the same manner as used with printf etc.</param>
        /// <param name="...">a variable number of arguments, to be included in the formatted string.</param>
        /// <remarks>Create, Destroy</remarks>
        public static void Write(global::OpenZWave.LogLevel _level, byte _nodeId, string _format)
        {
            __Internal.Write(_level, _nodeId, _format);
        }

        /// <summary>Send the queued log messages to the log output.</summary>
        public static void QueueDump()
        {
            __Internal.QueueDump();
        }

        /// <summary>Clear the log message queue</summary>
        public static void QueueClear()
        {
            __Internal.QueueClear();
        }

        /// <summary>Determine whether logging is enabled or not (retained for backward compatibility)</summary>
        /// <param name="_dologging">If true, logging is enabled; if false, disabled</param>
        /// <param name="_dologging">If true, logging is enabled; if false, disabled</param>
        /// <remarks>Enable or disable library logging (retained for backward compatibility)</remarks>
        public static bool LoggingState
        {
            get
            {
                var __ret = __Internal.GetLoggingState();
                return __ret;
            }

            set
            {
                __Internal.SetLoggingState(value);
            }
        }
    }

    public unsafe partial class ILogImplInternal : global::OpenZWave.ILogImpl, IDisposable
    {
        private static void* __CopyValue(global::OpenZWave.ILogImpl.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::OpenZWave.ILogImpl.__Internal));
            *(global::OpenZWave.ILogImpl.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ILogImplInternal(global::OpenZWave.ILogImpl.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ILogImplInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void QueueDump()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 8);
            var ___QueueDumpDelegate = (global::OpenZWave.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr));
            ___QueueDumpDelegate((__Instance + __PointerAdjustment));
        }

        public override void QueueClear()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 4 * 8);
            var ___QueueClearDelegate = (global::OpenZWave.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr));
            ___QueueClearDelegate((__Instance + __PointerAdjustment));
        }

        public override void SetLoggingState(global::OpenZWave.LogLevel _saveLevel, global::OpenZWave.LogLevel _queueLevel, global::OpenZWave.LogLevel _dumpTrigger)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 8);
            var ___SetLoggingStateDelegate = (global::OpenZWave.Delegates.Action_IntPtr_OpenZWave_LogLevel_OpenZWave_LogLevel_OpenZWave_LogLevel) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr_OpenZWave_LogLevel_OpenZWave_LogLevel_OpenZWave_LogLevel));
            ___SetLoggingStateDelegate((__Instance + __PointerAdjustment), _saveLevel, _queueLevel, _dumpTrigger);
        }

        public override void SetLogFileName(string _filename)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 8);
            var ___SetLogFileNameDelegate = (global::OpenZWave.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::OpenZWave.Delegates.Action_IntPtr_IntPtr));
            var __allocator0 = new global::Std.Allocator<sbyte>();
            var __basicString0 = global::Std.BasicStringExtensions.BasicString(_filename, __allocator0);
            var __arg0 = __basicString0.__Instance;
            ___SetLogFileNameDelegate((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
        }
    }
}

namespace OpenZWave
{
    public enum SecurityStrategy : uint
    {
        SecurityStrategyEssential = 0,
        SecurityStrategySupported = 1
    }

    public unsafe partial class ZWSecurity
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave13EncyrptBufferEPhhPNS_6DriverEhhPKhS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool EncyrptBuffer(byte* m_buffer, byte m_length, global::System.IntPtr driver, byte _sendingNode, byte _receivingNode, byte[] m_nonce, byte* e_buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave13DecryptBufferEPhhPNS_6DriverEhhPKhS0_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DecryptBuffer(byte* e_buffer, byte e_length, global::System.IntPtr driver, byte _sendingNode, byte _receivingNode, byte[] m_nonce, byte* m_buffer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave22GenerateAuthenticationEPKhjPNS_6DriverEhhPhS4_")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GenerateAuthentication(byte* _data, uint _length, global::System.IntPtr driver, byte _sendingNode, byte _receivingNode, byte* iv, byte* _authentication);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("openzwave-1.4", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="_ZN9OpenZWave24ShouldSecureCommandClassEh")]
            internal static extern global::OpenZWave.SecurityStrategy ShouldSecureCommandClass(byte CommandClass);
        }

        public static bool EncyrptBuffer(byte* m_buffer, byte m_length, global::OpenZWave.Driver driver, byte _sendingNode, byte _receivingNode, byte[] m_nonce, byte* e_buffer)
        {
            var __arg2 = ReferenceEquals(driver, null) ? global::System.IntPtr.Zero : driver.__Instance;
            if (m_nonce == null || m_nonce.Length != 8)
                throw new ArgumentOutOfRangeException("m_nonce", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.EncyrptBuffer(m_buffer, m_length, __arg2, _sendingNode, _receivingNode, m_nonce, e_buffer);
            return __ret;
        }

        public static bool DecryptBuffer(byte* e_buffer, byte e_length, global::OpenZWave.Driver driver, byte _sendingNode, byte _receivingNode, byte[] m_nonce, byte* m_buffer)
        {
            var __arg2 = ReferenceEquals(driver, null) ? global::System.IntPtr.Zero : driver.__Instance;
            if (m_nonce == null || m_nonce.Length != 8)
                throw new ArgumentOutOfRangeException("m_nonce", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DecryptBuffer(e_buffer, e_length, __arg2, _sendingNode, _receivingNode, m_nonce, m_buffer);
            return __ret;
        }

        public static bool GenerateAuthentication(byte* _data, uint _length, global::OpenZWave.Driver driver, byte _sendingNode, byte _receivingNode, byte* iv, byte* _authentication)
        {
            var __arg2 = ReferenceEquals(driver, null) ? global::System.IntPtr.Zero : driver.__Instance;
            var __ret = __Internal.GenerateAuthentication(_data, _length, __arg2, _sendingNode, _receivingNode, iv, _authentication);
            return __ret;
        }

        public static global::OpenZWave.SecurityStrategy ShouldSecureCommandClass(byte CommandClass)
        {
            var __ret = __Internal.ShouldSecureCommandClass(CommandClass);
            return __ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_OpenZWave_LogLevel_OpenZWave_LogLevel_OpenZWave_LogLevel(global::System.IntPtr _0, global::OpenZWave.LogLevel _1, global::OpenZWave.LogLevel _2, global::OpenZWave.LogLevel _3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr _0, global::System.IntPtr _1);
    }
}

namespace Std
{
    namespace __1
    {
        namespace Pair
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair____N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C____N_OpenZWave_S_Options_S_Option
            {
                [FieldOffset(0)]
                internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C first;

                [FieldOffset(24)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__1__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C____N_OpenZWave_S_Options_S_Option
            {
                [FieldOffset(0)]
                internal global::Std.BasicString.__Internalc__N_std_N___1_S_basic_string__C___N_std_N___1_S_char_traits__C___N_std_N___1_S_allocator__C first;

                [FieldOffset(24)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__i____N_OpenZWave_S_Driver
            {
                [FieldOffset(0)]
                internal uint first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__1i____N_OpenZWave_S_Driver
            {
                [FieldOffset(0)]
                internal uint first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__c____N_OpenZWave_S_Node_S_DeviceClass
            {
                [FieldOffset(0)]
                internal byte first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__1c____N_OpenZWave_S_Node_S_DeviceClass
            {
                [FieldOffset(0)]
                internal byte first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__c____N_OpenZWave_S_Group
            {
                [FieldOffset(0)]
                internal byte first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__1c____N_OpenZWave_S_Group
            {
                [FieldOffset(0)]
                internal byte first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair____N_OpenZWave_S_InstanceAssociation___N_std_N___1_S_vector____N_OpenZWave_S_Group_S_AssociationCommand___N_std_N___1_S_allocator__S2_
            {
                [FieldOffset(0)]
                internal global::OpenZWave.InstanceAssociation.__Internal first;

                [FieldOffset(8)]
                internal global::Std.Vector.__Internalc__N_std_N___1_S_vector____N_OpenZWave_S_Group_S_AssociationCommand___N_std_N___1_S_allocator__S0_ second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__1__N_OpenZWave_S_InstanceAssociation___N_std_N___1_S_vector____N_OpenZWave_S_Group_S_AssociationCommand___N_std_N___1_S_allocator__S2_
            {
                [FieldOffset(0)]
                internal global::OpenZWave.InstanceAssociation.__Internal first;

                [FieldOffset(8)]
                internal global::Std.Vector.__Internalc__N_std_N___1_S_vector____N_OpenZWave_S_Group_S_AssociationCommand___N_std_N___1_S_allocator__S0_ second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__c____N_OpenZWave_S_CommandClass
            {
                [FieldOffset(0)]
                internal byte first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }

            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public unsafe partial struct __Internalc__N_std_N___1_S_pair__1c____N_OpenZWave_S_CommandClass
            {
                [FieldOffset(0)]
                internal byte first;

                [FieldOffset(8)]
                internal global::System.IntPtr second;
            }
        }

    }
}
namespace Std
{
    namespace __1
    {
        namespace __list_node
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public unsafe partial struct __Internalc__N_std_N___1_S___list_node____N_OpenZWave_S_Node_S_CommandClassData__v
            {
                [FieldOffset(0)]
                internal global::System.IntPtr __prev_;

                [FieldOffset(8)]
                internal global::System.IntPtr __next_;

                [FieldOffset(16)]
                internal global::OpenZWave.Node.CommandClassData.__Internal __value_;
            }

            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public unsafe partial struct __Internal_Ptr
            {
                [FieldOffset(0)]
                internal global::System.IntPtr __prev_;

                [FieldOffset(8)]
                internal global::System.IntPtr __next_;

                [FieldOffset(16)]
                internal global::System.IntPtr __value_;
            }

            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public unsafe partial struct __Internalc__N_std_N___1_S___list_node____N_OpenZWave_S_Driver_S_PollEntry__v
            {
                [FieldOffset(0)]
                internal global::System.IntPtr __prev_;

                [FieldOffset(8)]
                internal global::System.IntPtr __next_;

                [FieldOffset(16)]
                internal global::OpenZWave.Driver.PollEntry.__Internal __value_;
            }
        }
    }
}
